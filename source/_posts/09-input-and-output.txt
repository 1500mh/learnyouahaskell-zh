=輸入與輸出 #input-and-output

我們已經說明了Haskell是一個純粹函數式語言。
雖說在命令式語言中我們習慣給電腦執行一連串指令，
在函數式語言中我們是用定義東西的方式進行。
在Haskell中，一個函數不能改變狀態，
像是改變一個變數的內容。
(當一個函數會改變狀態，我們說這函數是有副作用的。)
在Haskell中函數唯一可以做的事是根據我們給定的參數來算出的結果。
如果我們用同樣的參數呼叫兩次同一個函數，
它會回傳相同的結果。
儘管這從命令列語言的角度來看是蠻大的限制，我們已經看過它可以達成多麼酷的效果。
在一個命令式語言中，
程式語言沒辦法給你任何保證在一個簡單如印出幾個數字的函數不會同時燒掉你的房子，
綁架你的狗並刮傷你車子的烤漆。
例如，
當我們要做一個二元樹的時候，
我們並不插入一個結點來改變原有的樹。
由於我們無法改變狀態，我們的函數實際上回傳了一棵新的二元樹。


函數無法改變狀態的好處是它讓我們促進了我們理解程式的容易度，
但同時也造成了一個問題。
假如說一個函數無法改變現實世界的狀態，
那它要如何印出它所計算的結果?
畢竟要告訴我們結果的話，
它必須要改變輸出裝置的狀態(譬如說螢幕)，
然後從螢幕傳達到我們的腦，並改變我們心智的狀態。

不要太早下結論，
Haskell實際上設計了一個非常聰明的系統來處理有副作用的函數，
它漂亮地將我們的程式區分成純粹跟非純粹兩部分。
非純粹的部分負責跟鍵盤還有螢幕溝通。
有了這區分的機制，
在跟外界溝通的同時，
我們還是能夠有效運用純粹所帶來的好處，像是惰性求值、容錯性跟模組性


==Hello, world!

到目前為止我們都是將函數載入GHCi中來測試，像是標準函式庫中的一些函式。
但現在我們要做些不一樣的，寫一個真實跟世界互動的Haskell程式。
當然不例外，我們會來寫個"hello world"。

現在，我們把下一行打到你熟悉的編輯器中
{{
main = putStrLn "hello, world"
}}
我們定義了一個``main``，並在裡面以``"hello, world"``為參數呼叫了``putStrLn``。
看起來沒什麼大不了，但不久你就會發現它的奧妙。
把這程式存成``helloworld.hs``。

現在我們將做一件之前沒做過的事: 編譯你的程式。
打開你的終端並切換到包含``helloworld.hs``的目錄，並輸入下列指令。
{{
$ ghc --make helloworld
[1 of 1] Compiling Main                 ( helloworld.hs, hellowowlrd.o )
Linking helloworld ...
}}

順利的話你就會得到如上的訊息，接著你便可以執行你的程式``./helloworld``
{{
$ ./helloworld
hello, world
}}
這就是我們第一個編譯成功並印出字串到螢幕的程式。很簡單吧。

讓我們來看一下我們究竟做了些什麼，
首先來看一下``putStrLn``函數的型態
{{
ghci> :t putStrLn
putStrLn :: String -> IO ()
ghci> :t putStrLn "hello, world"
putStrLn "hello, world" :: IO ()
}}
我們可以這麼解讀``putStrLn``的型態:
``putStrLn``接受一個字串並回傳一個I/O action，這I/O action包含了``()``的型態。
(即空的tuple，或者是unit型態)。
一個I/O action是一個會造成副作用的動作，常是指讀取輸入或輸出到螢幕，
同時也代表會回傳某些值。
在螢幕印出幾個字串並沒有什麼有意義的回傳值可言，
所以這邊用一個``()``來代表。

那究竟I/O action會在什麼時候被觸發呢?
這就是``main``的公用所在。
一個I/O action會在我們把它綁定到``main``這個名字並且執行程式的時候觸發。

把整個程式限制在只能有一個I/O action看似是個極大的限制。
這就是為什麼我們需要do表示法來將所有I/O action綁成一個。
來看看下面這個例子。

{{
main = do
    putStrLn "Hello, what's your name?"
    name <- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
}}

新的語法，有趣吧! 它看起來就像一個命令式的程式。
如果你編譯並執行它，它便會照你預期的方式執行。
我們寫了一個do並且接著一連串指令，就像寫個命令式程式一般，每一步都是一個I/O action。
將所有I/O action用do綁在一起變成了一個大的I/O action。
這個大的I/O action的型態是``IO ()``，
這完全是由最後一個I/O action所決定的。

這就是為什麼``main``的型態永遠都是``main :: IO something``，
其中``something``是某個具體的型態。
按照慣例，我們通常是不會把``main``的型態在程式中寫出來。

另一個有趣的事情是第三行``name <- getLine``。
它看起來像是從輸入讀取一行並存到一個變數``name``之中。
真的是這樣嗎? 我們來看看``getLine``的型態吧
{{
ghci> :t getLine
getLine :: IO String
}}

我們可以看到``getLine``是一個回傳``String``的I/O action。
因為它會等使用者輸入某些字串，這很合理。
那``name <- getLine``又是如何?
你能這樣解讀它: 執行一個I/O action ``getLine``並將它的結果綁定到``name``這個名字。
``getLine``的型態是``IO String``，
所以``name``的型態會是``String``。
你能把I/O action想程式一個長了腳的盒子，它會跑到真實世界中替你做某些事，
像是在牆壁上塗鴉，然後帶回來某些資料。
一旦它帶了某些資料給你，打開盒子的唯一辦法就是用``<-``。
而且如果我們要從I/O action拿出某些資料，就一定同時要在另一個I/O action中。
這就是Haskell如何漂亮地分開純粹跟不純粹的程式的方法。
``getLine``在這樣的意義下是不純粹的，因為執行兩次的時候它沒辦法保證會回傳一樣的值。
這也是為什麼它需要在一個``IO``的型態建構子中，那樣我們才能在I/O actio中取出資料。
而且任何一段程式一旦依賴著I/O資料的話，那段程式也會被視為I/O code。

但這不表示我們不能在純粹的程式碼中使用I/O action回傳的資料。
只要我們綁定它到一個名字，我們便可以暫時地使用它。
像在``name <-getLine``中``name``不過是一個普通字串，代表在盒子中的內容。
我們能將這個普通的字串傳給一個極度複雜的函數，並回傳你一生會有多少財富。
像是這樣。
{{
main = do
    putStrLn "Hello, what's your name?"
    name <- getLine
    putStrLn $ "Read this carefully, because this is your future: " ++ tellFortune name
}}
``tellFortune``並不知道任何I/O有關的事，
它的型態只不過是``String -> String``。

再來看看這段程式碼吧，他是合法的嗎?
{{
nameTag = "Hello, my name is " ++ getLine
}}
如果你回答不是，恭喜你。
如果你說是，你答錯了。
這麼做不對的理由是``++``要求兩個參數都必須是串列。
他左邊的參數是``String``，也就是``[Char]``。
然而``getLine``的型態是``IO String``。
你不能串接一個字串跟I/O action。
我們必須先把``String``的值從I/O action中取出，
而唯一可行的方法就是在I/O action中使用``name <- getLine``。
如果我們需要處理一些非純粹的資料，那我們就要在非純粹的環境中做。
所以我們最好把I/O的部分縮減到最小的比例。

每個I/O action都有一個值封裝在裡面。
這也是為什麼我們之前的程式可以這麼寫。
{{
main = do
    foo <- putStrLn "Hello, what's your name?"
    name <- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
}}
然而，``foo``只會有一個``()``的值，
所以綁定到``foo``這個名字似乎是多餘的。
另外注意到我們並沒有綁定最後一行的``putStrLn``給任何名字。
那是因為在一個do block中，
最後一個action不能綁定任何名字。
我們在之後講解Monad的時候會說明為什麼。
現在你可以先想成do block會自動從最後一個action取出值並綁定給他的結果。

除了最後一行之外，
其他在do中沒有綁定名字的其實也可以寫成綁定的形式。
所以``putStrLn "BLAH"``可以寫成``_ <- putStrLn "BLAH"``。
但這沒什麼實際的意義，所以我們寧願寫成``putStrLn something``。




==檔案與字符流

==命令列引數

==亂數

==Bytestrings

==例外

