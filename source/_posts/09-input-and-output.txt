=輸入與輸出 #input-and-output

我們已經說明了Haskell是一個純粹函數式語言。
雖說在命令式語言中我們習慣給電腦執行一連串指令，
在函數式語言中我們是用定義東西的方式進行。
在Haskell中，一個函數不能改變狀態，
像是改變一個變數的內容。
(當一個函數會改變狀態，我們說這函數是有副作用的。)
在Haskell中函數唯一可以做的事是根據我們給定的參數來算出的結果。
如果我們用同樣的參數呼叫兩次同一個函數，
它會回傳相同的結果。
儘管這從命令列語言的角度來看是蠻大的限制，我們已經看過它可以達成多麼酷的效果。
在一個命令式語言中，
程式語言沒辦法給你任何保證在一個簡單如印出幾個數字的函數不會同時燒掉你的房子，
綁架你的狗並刮傷你車子的烤漆。
例如，
當我們要做一個二元樹的時候，
我們並不插入一個結點來改變原有的樹。
由於我們無法改變狀態，我們的函數實際上回傳了一棵新的二元樹。


函數無法改變狀態的好處是它讓我們促進了我們理解程式的容易度，
但同時也造成了一個問題。
假如說一個函數無法改變現實世界的狀態，
那它要如何印出它所計算的結果?
畢竟要告訴我們結果的話，
它必須要改變輸出裝置的狀態(譬如說螢幕)，
然後從螢幕傳達到我們的腦，並改變我們心智的狀態。

不要太早下結論，
Haskell實際上設計了一個非常聰明的系統來處理有副作用的函數，
它漂亮地將我們的程式區分成純粹跟非純粹兩部分。
非純粹的部分負責跟鍵盤還有螢幕溝通。
有了這區分的機制，
在跟外界溝通的同時，
我們還是能夠有效運用純粹所帶來的好處，像是惰性求值、容錯性跟模組性


==Hello, world!

到目前為止我們都是將函數載入GHCi中來測試，像是標準函式庫中的一些函式。
但現在我們要做些不一樣的，寫一個真實跟世界互動的Haskell程式。
當然不例外，我們會來寫個"hello world"。

現在，我們把下一行打到你熟悉的編輯器中
{{
main = putStrLn "hello, world"
}}
我們定義了一個``main``，並在裡面以``"hello, world"``為參數呼叫了``putStrLn``。
看起來沒什麼大不了，但不久你就會發現它的奧妙。
把這程式存成``helloworld.hs``。

現在我們將做一件之前沒做過的事: 編譯你的程式。
打開你的終端並切換到包含``helloworld.hs``的目錄，並輸入下列指令。
{{
$ ghc --make helloworld
[1 of 1] Compiling Main                 ( helloworld.hs, hellowowlrd.o )
Linking helloworld ...
}}

順利的話你就會得到如上的訊息，接著你便可以執行你的程式``./helloworld``
{{
$ ./helloworld
hello, world
}}
這就是我們第一個編譯成功並印出字串到螢幕的程式。很簡單吧。

讓我們來看一下我們究竟做了些什麼，
首先來看一下``putStrLn``函數的型態
{{
ghci> :t putStrLn
putStrLn :: String -> IO ()
ghci> :t putStrLn "hello, world"
putStrLn "hello, world" :: IO ()
}}
我們可以這麼解讀``putStrLn``的型態:
``putStrLn``接受一個字串並回傳一個I/O action，這I/O action包含了``()``的型態。
(即空的tuple，或者是unit型態)。
一個I/O action是一個會造成副作用的動作，常是指讀取輸入或輸出到螢幕，
同時也代表會回傳某些值。
在螢幕印出幾個字串並沒有什麼有意義的回傳值可言，
所以這邊用一個``()``來代表。

那究竟I/O action會在什麼時候被觸發呢?
這就是``main``的公用所在。
一個I/O action會在我們把它綁定到``main``這個名字並且執行程式的時候觸發。

把整個程式限制在只能有一個I/O action看似是個極大的限制。
這就是為什麼我們需要do表示法來將所有I/O action綁成一個。
來看看下面這個例子。

{{
main = do
    putStrLn "Hello, what's your name?"
    name <- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
}}

新的語法，有趣吧! 它看起來就像一個命令式的程式。
如果你編譯並執行它，它便會照你預期的方式執行。
我們寫了一個do並且接著一連串指令，就像寫個命令式程式一般，每一步都是一個I/O action。
將所有I/O action用do綁在一起變成了一個大的I/O action。
這個大的I/O action的型態是``IO ()``，
這完全是由最後一個I/O action所決定的。



==檔案與字符流

==命令列引數

==亂數

==Bytestrings

==例外

