=來看看幾種Monad #a-fistful-of-monads

當我們第一次談到Functor的時候，我們了解到他是一個抽象概念，代表是一種可以被map over的值。然後我們再將其概念提升到Applicative Functor，他代表一種帶有context的型態，我們可以用函數操作他而且同時還保有他的context。

在這一章，我們會學到Monad，基本上他是一種加強版的Applicative Functor，正如Applicative Functor是Functor的加強版一樣。

我們介紹到Functor是因為我們觀察到有許多型態都可以被function給map over，了解到這個目的，便抽象化了``Functor``這個typeclass出來。但這讓我們想問：如果給定一個``a -> b``的函數以及``f a``的型態，我們要如何將函數map over這個型態而得到``f b``？我們知道要如何map over ``Maybe a``，``[a]``以及``IO a``。我們甚至還知道如何用``a -> b`` map over ``r -> a``，並且會得到``r -> b``。要回答這個問題，我們只需要看``fmap``的型態就好了：

{{
fmap :: (Functor f) => (a -> b) -> f a -> f b      
}}

然後只要針對``Functor`` instance撰寫對應的實做。

之後我們又看到一些可以針對Functor改進的地方，例如``a -> b``也被包在一個Functor value裡面呢？像是``Just (*3)``，我們要如何apply ``Just 5``給他？如果我們不要apply ``Just 5``而是``Nothing``呢？甚至給定``[(*2),(+4)]``，我們要如何apply他們到``[1,2,3]``呢？對於此，我們抽象出``Applicative`` typeclass，這就是我們想要問的問題：

{{
(<*>) :: (Applicative f) => f (a -> b) -> f a -> f b     
}}

我們也看到我們可以將一個正常的值包在一個資料型態中。例如說我們可以拿一個``1``然後把他包成``Just 1``。或是把他包成``[1]``。也可以是一個I/O action會產生一個``1``。這樣包裝的function我們叫他做``pure``。

如我們說得，一個applicative value可以被看作一個有附加context的值。例如說，``'a'``只是一個普通的字元，但``Just 'a'``是一個附加了context的字元。他不是``Char``而是``Maybe Char``，這型態告訴我們這個值可能是一個字元，也可能什麼都沒有。

來看看``Applicative`` typeclass怎樣讓我們用普通的function操作他們，同時還保有context：
{{
ghci> (*) <$> Just 2 <*> Just 8  
Just 16  
ghci> (++) <$> Just "klingon" <*> Nothing  
Nothing  
ghci> (-) <$> [3,4] <*> [1,2,3]  
[2,1,0,3,2,1]  
}}

所以我們可以視他們為aaplicative values，``Maybe a``代表可能會失敗的computation，``[a]``代表同時有好多結果的computation (non-deterministic computation)，而``IO a``代表會有side-effects的computation。

Monad是一個從Applicative functors很自然的一個演進結果。對於他們我們主要考量的點是：如果你有一個具有context的值``m a``，你能如何把他丟進一個只接受普通值``a``的函數中，並回傳一個具有context的值？也就是說，你如何套用一個型態為``a -> m b``的函數至``m a``？基本上，我們要求的函數是：

{{
(>>=) :: (Monad m) => m a -> (a -> m b) -> m b
}}

如果我們有一個漂亮的值跟一個函數接受普通的值但回傳漂亮的值，那我們要如何要把漂亮的值丟進函數中？這就是我們使用Monad時所要考量的事情。我們不寫成``f a``而寫成``m a``是因為``m``代表的是``Monad``，但monad不過就是支援``>>=``操作的applicative functors。``>>=``我們稱呼他為bind。

當我們有一個普通值``a``跟一個普通函數``a -> b``，要套用函數是一件很簡單的事。但當你在處理具有context的值時，就需要多考慮些東西，要如何把漂亮的值餵進函數中，並如何考慮他們的行為，但你將會了解到他們其實不難。

==動手做做看: Maybe Monad

現在對於什麼是Monad已經有了些模糊的概念，
我們來看看要如何讓這概念更具體一些。

不意外地，``Maybe``是一個Monad，
所以讓我們對於他多探討些，看看是否能跟我們所知的Monad概念結合起來。

    到這邊要確定你了解什麼是Applicatives。如果你知道好幾種``Applicative``的instance還有他們代表的意含就更好了，因為monad不過就是對applicative的概念進行一次升級。


一個``Maybe a``型態的值代表型態為``a``的值而且具備一個可能造成錯誤的context。而``Just "dharma"``的值代表他不是一個``"dharma"``的字串就是字串不見時的``Nothing``。如果你把字串當作計算的結果，``Nothing``就代表計算失敗了。

當我們把``Maybe``視作functor，我們其實要的是一個``fmap``來把一個函數針對其中的元素做套用。他會對``Just``中的元素進行套用，要不然就是保留``Nothing``的狀態，其代表裡面根本沒有元素。

{{
ghci> fmap (++"!") (Just "wisdom")  
Just "wisdom!"  
ghci> fmap (++"!") Nothing  
Nothing  
}}

或者視為一個applicative functor，他也有類似的作用。只是applicative也把函數包了起來。``Maybe``作為一個applicative functor，我們能用``<*>``來套用一個存在``Maybe``中的函數至包在另外一個``Maybe``中的值。他們都必須是包在``Just``來代表值存在，要不然其實就是``Nothing``。當你在想套用函數到值上面的時候，缺少了函數或是值都會造成錯誤，所以這樣做是很合理的。

{{
ghci> Just (+3) <*> Just 3  
Just 6  
ghci> Nothing <*> Just "greed"  
Nothing  
ghci> Just ord <*> Nothing  
Nothing  
}}

當我們用applicative的方式套用函數至``Maybe``型態的值時，就跟上面描述的差不多。過程中所有值都必須是``Just``，要不然結果一定會是``Nothing``。

{{
ghci> max <$> Just 3 <*> Just 6  
Just 6  
ghci> max <$> Just 3 <*> Nothing  
Nothing  
}}

我們來思考一下要怎麼為``Maybe``實作``>>=``。正如我們之前提到的，``>>=``接受一個monadic value，以及一個接受普通值的函數，這函數會回傳一個monadic value。``>>=``會幫我們套用這個函數到這個monadic value。在函數只接受普通值的情況俠，函數是如何作到這件事的呢？要作到這件事，他必須要考慮到monadic value的context。

在這個案例中，``>>=``會接受一個``Maybe a``以及一個型態為``a -> Maybe b``的函數。他會套用函數到``Maybe a``。要釐清他怎麼作到的，首先我們注意到``Maybe``的applicative functor特性。假設我們有一個函數``\x -> Just (x+1)``。他接受一個數字，把他加``1``後再包回``Just``。

{{
ghci> (\x -> Just (x+1)) 1  
Just 2  
ghci> (\x -> Just (x+1)) 100  
Just 101 
}}

如果我們餵給函數``1``，他會計算成``Just 2``。如果我們餵給函數``100``，那結果便是``Just 101``。但假如我們餵一個``Maybe``的值給函數呢？如果我們把``Maybe``想成一個applicative functor，那答案便很清楚。如果我們拿到一個``Just``，就把包在``Just``裡面的值餵給函數。如果我們拿到一個``Nothing``，我們就說結果是``Nothing``。

我們呼叫``applyMaybe``而不呼叫``>>=``。他接受``Maybe a``跟一個回傳``Maybe b``的函數，並套用函數至``Maybe a``。

{{
applyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b  
applyMaybe Nothing f  = Nothing  
applyMaybe (Just x) f = f x  
}}

我們套用一個infix函數，這樣``Maybe``的值可以寫在左邊且函數是在右邊：

{{
ghci> Just 3 `applyMaybe` \x -> Just (x+1)  
Just 4  
ghci> Just "smile" `applyMaybe` \x -> Just (x ++ " :")""  
Just "smile :""  
ghci> Nothing `applyMaybe` \x -> Just (x+1)  
Nothing  
ghci> Nothing `applyMaybe` \x -> Just (x ++ " :")")  
Nothing 
}}

在上述的範例中，我們看到在套用``applyMaybe``的時候，函數是套用在``Just``裡面的值。當我們試圖套用到``Nothing``，那整個結果便是``Nothing``。假如函數回傳``Nothing``呢？

{{
ghci> Just 3 `applyMaybe` \x -> if x > 2 then Just x else Nothing  
Just 3  
ghci> Just 1 `applyMaybe` \x -> if x > 2 then Just x else Nothing  
Nothing  
}}

這正是我們期待的結果。如果左邊的monadic value是``Nothing``，那整個結果就是``Nothing``。如果右邊的函數是``Nothing``，那結果也會是``Nothing``。這跟我們之前把``Maybe``當作aaplicative時，過程中有任何一個``Nothing``整個結果就會是``Nothing``一樣。

對於``Maybe``而言，我們已經找到一個方法處理漂亮值的方式。我們作到這件事的同時，也保留了``Maybe``代表可能造成錯誤的計算的意義。

你可能會問，這樣的結果有用嗎？由於applicative functors讓我們可以拿一個接受普通值的函數，並讓他可以操作具有context的值，這樣看起來applicative functors好像比monad強。但我們會看到monad也能作到，因為他只是applicative functors的升級版。他們同時也能作到applicative functors不能作到的事情。

稍候我們會再繼續探討``Maybe``，但我們先來看看monad的type class。


==Monad type class

正如functors有``Functor``這個type class，而applicative functors有一個``Applicative`` 這個type class，monad也有他自己的type class：``Monad``他看起來像這樣：

{{
class Monad m where  
    return :: a -> m a  

    (>>=) :: m a -> (a -> m b) -> m b  

    (>>) :: m a -> m b -> m b  
    x >> y = x >>= \_ -> y  

    fail :: String -> m a  
    fail msg = error msg  
}}

我們從第一行開始看。他說``class Monad m where``。但我們之前不是提到monad是applicative functors的加強版嗎？不是應該有一個限制說一個型態必須先是一個applicative functor才可能是一個monad嗎？像是``class (Applicative m) = > Monad m where``。他的確應該要有，但當Haskell被創造的早期，人們沒有想到applicative functor適合被放進語言中，所以最後沒有這個限制。但的確每個monad都是applicative functor，即使``Monad``並沒有這麼宣告。

在``Monad`` typeclass中定義的第一個函數是``return``。
他其實等價於``pure``，只是名字不同罷了。
他的型態是``(Monad m) => a -> m a``。
他接受一個普通值並把他放進一個最小的context中。
也就是說他把普通值包進一個monad裡面。
他跟``Applicative``裡面``pure``函數做的事情一樣，
所以說其實我們已經認識了``return``。
我們已經用過``return``來處理一些I/O。
我們用他來做一些假的I/O，印出一些值。
對於``Maybe``來說他就是接受一個普通值然後包進``Just``。


    提醒一下：``return``跟其他語言中的``return``是完全不一樣的。他並不是結束一個函數的執行，他只不過是把一個普通值包進一個context裡面。


接下來定義的函數是bind: ``>>=``。他就像是函數套用一樣，只差在他不接受普通值，他是接受一個monadic value（也就是具有context的值）並且把他餵給一個接受普通值得函數，並回傳一個monadic value。


接下來，我們定義了``>>``。我們不會介紹他，因為他有一個事先定義好的實作，基本上我們在實作``Monad`` typeclass的時候都不會去理他。

最後一個函數是``fail``。我們通常在我們程式中不會具體寫出來。他是被Haskell用在處理語法錯誤的情況。我們目前不需要太在意``fail``。

我們知道了``Monad`` typeclass長什麼樣子，我們來看一下``Maybe``的``Monad`` instance。

{{
ghci> return "WHAT" :: Maybe String  
Just "WHAT"  
ghci> Just 9 >>= \x -> return (x*10)  
Just 90  
ghci> Nothing >>= \x -> return (x*10)  
Nothing 
}}

第一行沒什麼了不起，我們已經知道``return``就是``pure``而我們又對``Maybe``操作過``pure``了。至於下兩行就比較有趣點。

留意我們是如何把``Just 9``餵給``\x -> return (x*10)``。在函數中``x``綁定到``9``。他看起好像我們能不用pattern matching的方式就從``Maybe``中抽取出值。但我們並沒有喪失掉``Maybe``的context，當他是``Nothing``的時候，``>>=``的結果也會是``Nothing``。


==走鋼索

我們已經知道要如何把``Maybe a``餵進``a -> Maybe b``這樣的函數。我們可以看看我們如何重複使用``>>=``來處理多個``Maybe a``的值。

首先來說個小故事。皮爾斯決定要辭掉他的工作改行試著走鋼索。他對走鋼索蠻在行的，不過仍有個小問題。就是鳥會停在他拿的平衡竿上。他們會飛過來停一小會兒，然後再飛走。這樣的情況在兩邊的鳥的數量一樣時並不是個太大的問題。但有時候，所有的鳥都會想要停在同一邊，皮爾斯就失去了平衡，就會讓他從鋼索上掉下去。

我們這邊假設兩邊的鳥差異在三個之內的時候，皮爾斯仍能保持平衡。所以如果是右邊有一隻，左邊有四隻的話，那還撐得住。但如果左邊有五隻，那就會失去平衡。

我們要寫個程式來模擬整個情況。我們想看看皮爾斯究竟在好幾隻鳥來來去去後是否還能撐住。例如說，我們想看看先來了一隻鳥停在左邊，然後來了四隻停在右邊，然後左邊那隻飛走了。之後會是什麼情形。

我們用一對整數來代表我們的平衡竿狀態。頭一個位置代表左邊的鳥的數量，第二個位置代表右邊的鳥的數量。

{{
type Birds = Int  
type Pole = (Birds,Birds)  
}}

由於我們用整數來代表有多少隻鳥，我們便先來定義``Int``的同義型態，叫做``Birds``。然後我們把``(Birds, Birds)``定義成``Pole``。

接下來，我們定義一個函數他接受一個數字，然後把他放在竿子的左邊，還有另外一個函數放在右邊。

{{
landLeft :: Birds -> Pole -> Pole  
landLeft n (left,right) = (left + n,right)  
  
landRight :: Birds -> Pole -> Pole  
landRight n (left,right) = (left,right + n)  
}}

我們來試著執行看看：

{{
ghci> landLeft 2 (0,0)  
(2,0)  
ghci> landRight 1 (1,2)  
(1,3)  
ghci> landRight (-1) (1,2)  
(1,1)  
}}

要模擬鳥飛走的話我們只要給定一個負數就好了。 由於這些操作是接受``Pole``並回傳``Pole``， 所以我們可以把函數串在一起。

{{
ghci> landLeft 2 (landRight 1 (landLeft 1 (0,0)))  
(3,1)
}}

當我們餵``(0,0)``給``landLeft 1``時，我們會得到``(1,0)``。接著我們模擬右邊又停了一隻鳥，狀態就變成``(1,1)``。最後又有兩隻鳥停在左邊，狀態變成``(3,1)``。我們這邊的寫法是先寫函數名稱，然後再套用參數。但如果先寫pole再寫函數名稱會比較清楚，所以我們會想定義一個函數

{{
x -: f = f x
}}

我們能先套用參數然後再寫函數名稱：

{{
ghci> 100 -: (*3)  
300  
ghci> True -: not  
False  
ghci> (0,0) -: landLeft 2  
(2,0)  
}}

有了這個函數，我們便能寫得比較好讀一些：

{{
ghci> (0,0) -: landLeft 1 -: landRight 1 -: landLeft 2  
(3,1)  
}}

這個範例跟先前的範例是等價的，只不過好讀許多。很清楚的看出我們是從``(0,0)``開始，然後停了一隻在左邊，接著右邊又有一隻，最後左邊多了兩隻。

到目前為止沒什麼問題，但如果我們要停10隻在左邊呢？

{{ 
ghci> landLeft 10 (0,3)  
(10,3)  
}}

你說左邊有10隻右邊卻只有3隻？那不是早就應該掉下去了？這個例子太明顯了，如果換個比較不明顯的例子。

{{
ghci> (0,0) -: landLeft 1 -: landRight 4 -: landLeft (-1) -: landRight (-2)  
(0,2)  
}}

表面看起來沒什麼問題，但如果你仔細看的話，有一瞬間是右邊有四隻，但左邊沒有鳥。要修正這個錯誤，我們要重新檢視``landLeft``跟``landRight``。我們其實是希望這些函數產生失敗的情況。那就是在維持平衡的時候回傳新的pole，但失敗的時候告訴我們失敗了。這時候``Maybe``就剛剛好是我們要的context了。我們用``Maybe``重新寫一次：

{{
landLeft :: Birds -> Pole -> Maybe Pole  
landLeft n (left,right)  
    | abs ((left + n) - right) < 4 = Just (left + n, right)  
    | otherwise                    = Nothing  
          
landRight :: Birds -> Pole -> Maybe Pole  
landRight n (left,right)  
    | abs (left - (right + n)) < 4 = Just (left, right + n)  
    | otherwise                    = Nothing  
}}

現在這些函數不回傳``Pole``而回傳``Maybe Pole``了。他們仍接受鳥的數量跟舊的的pole，但他們現在會檢查是否有太多鳥會造成皮爾斯失去平衡。我們用guards來檢查是否有差異超過三的情況。如果沒有，那就包一個在``Just``中的新的pole，如果是，那就回傳``Nothing``。

再來執行看看：

{{
ghci> landLeft 2 (0,0)  
Just (2,0)  
ghci> landLeft 10 (0,3)  
Nothing  
}}

一如預期，當皮爾斯不會掉下去的時候，我們就得到一個包在``Just``中的新pole。當太多鳥停在同一邊的時候，我們就會拿到``Nothing``。這樣很棒，但我們卻不知道怎麼把東西串在一起了。我們不能做``landLeft 1 (landRight 1 (0,0))``，因為當我們對``(0,0)``使用``landRight 1``時，我們不是拿到``Pole``而是拿到``Maybe Pole``。``landLeft 1``會拿到``Pole``而不是拿到``Maybe Pole``。

我們需要一種方法可以把拿到的``Maybe Pole``塞到拿``Pole``的函數中，然後回傳``Maybe Pole``。而我們有``>>=``，他對``Maybe``做的事就是我們要的

{{
ghci> landRight 1 (0,0) >>= landLeft 2  
Just (2,1)  
}}

``landLeft 2的型態是``Pole -> Maybe Pole``。我們不能餵給他``Maybe Pole``的東西。而``landRight 1 (0,0)``的結果就是``Maybe Pole``，所以我們用``>>=``來接受一個有context的值然後拿給``landLeft 2``。``>>=``的確讓我們把``Maybe``當作有context的值，因為當我們丟``Nothing``給``landLeft 2``的時候，結果會是``Nothing``。

{{ 
ghci> Nothing >>= landLeft 2  
Nothing  
}}

這樣我們可以把這些新寫的用``>>=``串在一起。讓monadic value可以餵進只吃普通值的函數。

來看看些例子：

{{
ghci> return (0,0) >>= landRight 2 >>= landLeft 2 >>= landRight 2  
Just (2,4)  
}}

我們最開始用``return``回傳一個pole並把他包在``Just``裡面。我們可以像往常套用``landRight 2``，不過我們不那麼做，我們改用``>>=``。``Just (0,0)``被餵到``landRight 2``，得到``Just (0,2)``。接著被餵到``landLeft 2``，得到``Just (2,2)``。

還記得我們之前引入失敗情況的例子嗎？

{{
ghci> (0,0) -: landLeft 1 -: landRight 4 -: landLeft (-1) -: landRight (-2)  
(0,2)  
}}

之前的例子並不會反應失敗的情況。但如果我們用``>>=``的話就可以得到失敗的結果。

{{
ghci> return (0,0) >>= landLeft 1 >>= landRight 4 >>= landLeft (-1) >>= landRight (-2)  
Nothing  
}}

正如預期的，最後的情形代表了失敗的情況。我們再進一步看看這是怎麼產生的。首先``return``把``(0,0)``放到一個最小的context中，得到``Just (0,0)``。然後是``Just (0.0) >>= landLeft 1``。由於``Just (0,0)``是一個``Just``的值。``landLeft 1``被套用至``(0,0)``而得到``Just (1,0)``。這反應了我們仍保持在平衡的狀態。接著是``Just (1,0) >>= landright 4``而得到了``Just (1,4)``。距離不平衡只有一步之遙了。他又被餵給``landLeft (-1)``，這組合成了``landLeft (-1) (1,4)``。由於失去了平衡，我們變得到了``Nothing``。而我們把``Nothing``餵給``landRight (-2)``，由於他是``Nothing``，也就自動得到了``Nothing``。

如果只把``Maybe``當作aaplicative用的話是沒有辦法達到我們要的效果的。你試著做一遍就會卡住。因為applicative functor並不允許applicative value之間有彈性的互動。他們最多就是讓我們可以用applicative style來傳遞參數給函數。applicative operators能拿到他們的結果並把他用applicative的方式餵給另一個函數，並把最終的applicative值放在一起。但在每一步之間並沒有太多允許我們作手腳的機會。而我們的範例需要每一步都倚賴前一步的結果。當每一隻鳥降落的時候，我們都會把前一步的結果拿出來看看。好知道結果到底應該成功或失敗。

我們也能寫出一個函數，完全不管現在究竟有幾隻鳥停在竿子上，只是要害皮爾斯滑倒。我們可以稱呼這個函數叫做``banana``：

{{
banana :: Pole -> Maybe Pole  
banana _ = Nothing  
}}

現在我們能把香蕉皮串到我們的過程中。他絕對會讓遇到的人滑倒。他完全不管前面的狀態是什麼都會產生失敗。

{{
ghci> return (0,0) >>= landLeft 1 >>= banana >>= landRight 1  
Nothing  
}}

``Just (1,0)``被餵給``banana``，而產生了``Nothing``，之後所有的結果便都是``Nothing``了。

要同樣表示這種忽略前面的結果，只注重眼前的monadic value的情況，其實我們可以用``>>``來表達。

{{
(>>) :: (Monad m) => m a -> m b -> m b  
m >> n = m >>= \_ -> n  
}}

一般來講，碰到一個完全忽略前面狀態的函數，他就應該只會回傳他想回傳的值而已。但碰到Monad，他們的context還是必須要被考慮到。來看一下``>>``串接``Maybe``的情況。

{{
ghci> Nothing >> Just 3  
Nothing  
ghci> Just 3 >> Just 4  
Just 4  
ghci> Just 3 >> Nothing  
Nothing  
}}

如果你把``>>``換成``>>= \_ ->``，那就很容易看出他的意思。

我們也可以把``banana``改用``>>``跟``Nothing``來表達：

{{
ghci> return (0,0) >>= landLeft 1 >> Nothing >>= landRight 1  
Nothing 
}}

我們得到了保證的失敗。


我們也可以看看假如我們故意不用把``Maybe``視為有context的值的寫法。他會長得像這樣：

{{
routine :: Maybe Pole  
routine = case landLeft 1 (0,0) of  
    Nothing -> Nothing  
    Just pole1 -> case landRight 4 pole1 of   
            Nothing -> Nothing  
            Just pole2 -> case landLeft 2 pole2 of  
                    Nothing -> Nothing  
                    Just pole3 -> landLeft 1 pole3  
}}

左邊先停了一隻鳥，然後我們停下來檢查有沒有失敗。當失敗的時候我們回傳``Nothing``。當成功的時候，我們在右邊停一隻鳥，然後再重複前面做的事情。把這些瑣事轉換成``>>=``證明了``Maybe`` Monad的力量，可以省去我們不少的時間。

注意到``Maybe``對``>>=``的實作，他其實就是在做碰到``Nothing``就會傳``Nothing``，碰到正確值就繼續用``Just``傳遞值。

在這個章節中，我們看過了好幾個函數，也見識了用``Maybe`` monad來表示失敗的context的力量。把普通的函數套用換成了``>>=``，讓我們可以輕鬆地應付可能會失敗的情況，並幫我們傳遞context。這邊的context就代表失敗的可能性，當我們套用函數到context的時候，就代表考慮進了失敗的情況。

==do表示法

Monad在Haskell中是十分重要的，所以我們還特別為了操作他設置了特別的語法：``do``表示法。我們在介紹I/O的時候已經用過``do``來把小的I/O action串在一起了。其實``do``並不只是可以用在``IO``，他可以用在任何monad上。他的原則是簡單明瞭，把monadic value串成一串。我們這邊來細看``do``是如何使用，以及為什麼我們十分倚賴他。

來看一下熟悉的例子：

{{
ghci> Just 3 >>= (\x -> Just (show x ++ "!"))  
Just "3!"  
}}

==List Monad

==Monad laws (單子律)

