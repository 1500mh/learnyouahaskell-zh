=Functors, Applicative Functors與Monoids #functors-applicative-functors-and-monoids

Haskell的一些特色，像是純粹性，高階函數，algebraic data types，typeclasses，這些讓我們可以從更高的角度來看到polymorphism這件事。不像OOP當中需要從龐大的型態階層來思考。我們只需要看看手邊的型態的行為，將他們跟適當地typeclass對應起來就可以了。像``Int``的行為跟很多東西很像。好比說他可以比較相不相等，可以從大到小排列，也可以將他們一一窮舉出來。

Typeclass的運用是很隨意的。我們可以定義自己的資料型態，然後描述他可以怎樣被操作，跟typeclass關聯起來便定義了他的行為。由於Haskell強大的型態系統，這讓我們只要讀函數的型態宣告就可以知道很多資訊。typeclass可以定義得很抽象很general。我們之前有看過typeclass定義了可以比較兩個東西是否相等，或是定義了可以比較兩個東西的大小。這些是既抽象但又描述簡潔的行為，但我們不會認為他們有什麼特別之處，因為我們時常碰到他們。最近我們看過了functor，基本上他們是一群可以被map over的物件。這是其中一個例子能夠抽象但又漂亮地描述行為。在這一章中，我們會詳加闡述functors，並會提到比較強一些的版本，也就是applicative functors。我們也會提到monoids。


==溫習Functors

[$img/frogtor.png]

我們已經在之前的章節提到functors。如果你還沒讀那個章節，也許你應該先去看看。或是你直接假裝你已經讀過了。

來快速複習一下：Functors是可以被map over的物件，像是lists，``Maybe``，trees等等。在Haskell中我們是用``Functor``這個typeclass來描述他。這個typeclass只有一個method，叫做``fmap``，他的型態是``fmap :: (a -> b) ->  fa -> f b``。這型態說明了如果給我一個從``a``映到``b``的函數，以及一個裝了``a``的盒子，我會回給你一個裝了``b``的盒子。就好像用這個函數將每個元素都轉成``b``一樣

    *給一點建議*。這盒子的比喻嘗試讓你抓到些functors是如何運作的感覺。在之後我們也會用相同的比喻來比喻applicative functors跟monads。在多數情況下這種比喻是恰當的，但不要過度引申，有些functors是不適用這個比喻的。一個比較正確的形容是functors是一個計算語境(computational context)。這個語境可能是這個computation可能帶有值，或是有可能會失敗(像``Maybe``跟``Either a``)，或是他可能有多個值(像lists)，等等。

如果一個type constructor要是``Functor``的instance，那他的kind必須是``* -> *``，這代表他必須剛好接受一個type當作type parameter。像是``Maybe``可以是Functor的一個instance，因為他接受一個type parameter，來做成像是``Maybe Int``，或是``Maybe String``。如果一個type constructor接受兩個參數，像是``Either``，我們必須給他兩個type parameter。所以我們不能這樣寫：``instance Functor Either where``，但我們可以寫``instance Functor (Either a) where``，如果我們把``fmap``限縮成只是``Either a``的，那他的型態就是``fmap :: (b -> c) -> Either a b -> Either a c``。就像你看到的，``Either a``的是固定的一部分，因為``Either a``只恰好接受一個type parameter，但``Either``則要接球兩個type parameters。這樣fmap的型態變成``fmap :: (b -> c) -> Either b -> Either c``，這不太合理。

我們知道有許多型態都是``Functor``的instance，像是``[]``，``Maybe``，``Either a``以及我們自己寫的``Tree``。我們也看到了如何用一個函數map他們。在這一章節，我們再多舉兩個例子，也就是``IO``跟``(->) r``。

如果一個值的型態是``IO String``，他代表的是一個會被計算成String結果的I/O action。我們可以用do syntax來把結果綁定到某個名稱。我們之前把I/O action比喻做長了腳的盒子，會到真實世界幫我們取一些值回來。我們可以檢視他們取了什麼值，但一旦看過，我們必須要把值放回盒子中。用這個比喻，``IO``的行為就像是一個functor。

我們來看看``IO``是怎麼樣的一個``Functor`` instance。當我們``fmap``用一個function來map over I/O action時，我們會想要拿回一個裝著已經用function映射過值的I/O action。

{{
instance Functor IO where
    fmap f action = do
        result <- action
        return (f result)
}}

對一個I/O action做map over動作的結果仍會是一個I/O action，所以我們才用do syntax來把兩個I/O action黏成一個。在``fmap``的實做中，我們先執行了原本傳進的I/O action，並把結果綁定成``result``。然後我們寫了``return (f result)``。``return``就如你所知道的，是一個只會回傳包了你傳給他東西的I/O action。還有一個do block的回傳值一定是他最後一個I/O action的回傳值。這也是為什麼我們需要return。其實他只是回傳包了``f result``的I/O action。

我們可以再多實驗一下來找到些感覺。來看看這段code：

{{
main = do line <- getLine   
        let line' = reverse line  
        putStrLn $ "You said " ++ line' ++ " backwards!"  
        putStrLn $ "Yes, you really said" ++ line' ++ " backwards!"  
}}

這程式要求使用者輸入一行文字，然後印出一行反過來的。
我們可以用``fmap``來改寫：

{{
main = do line <- fmap reverse getLine  
            putStrLn $ "You said " ++ line ++ " backwards!"  
            putStrLn $ "Yes, you really said" ++ line ++ " backwards!"  
}}

[^img/alien.png]

就像我們用``fmap`` ``reverse``來map over ``Just "blah"``會得到``Just "halb"``，我們也可以``fmap`` ``reverse``來map over ``getLine``。``getLine``是一個I/O action，他的type是``IO String``，而用``reverse``來map over他會回傳一個取回一個字串並``reverse``他的I/O action。就像我們apply一個function到一個``Maybe``一樣，我們也可以apply一個function到一個``IO``，只是這個``IO``會跑去外面拿回某些值。然後我們把結果用``<-``綁定到某個名稱，而這個名稱綁定的值是已經``reverse``過了。

而``fmap (++"!") getLine``這個I/O action表現得就像``getLine``，只是他的結果多了一個``"!"``在最後。

如果我們限縮``fmap``到``IO``型態上，那fmap的型態是``fmap :: (a -> b) -> IO a -> IO b``。``fmap``接受一個函數跟一個I/O action，並回傳一個I/O action包含了已經apply過function的結果。

如果你曾經注意到你想要將一個I/O action綁定到一個名稱上，只是為了要apply一個function。你可以考慮使用``fmap``，那會更漂亮地表達這件事。或者你想要對functor中的資料做transformation，你可以先將你要用的function寫在top level，或是把他作成一個lambda function，甚至用function composition。

{{
import Data.Char  
import Data.List  
  
main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine  
        putStrLn line  
}}

{{
$ runhaskell fmapping_io.hs  
hello there  
E-R-E-H-T- -O-L-L-E-H  
}}

正如你想的，``intersperse '-' . reverse . map toUpper``合成了一個function，他接受一個字串，將他轉成大寫，然後反過來，再用``intersperse '-'``安插'-'。他是比較漂亮版本的``(\xs -> intersperse '-' (reverse (map toUpper xs)))``。

另一個``Functor``的案例是``(->) r``，只是我們先前沒有注意到。你可能會困惑到底``(->) r``究竟代表什麼？一個``r -> a``的型態可以寫成``(->) r a``，就像是``2 + 3``可以寫成``(+) 2 3``一樣。我們可以從一個不同的角度來看待``(->) r a``，他其實只是一個接受兩個參數的type constructor，好比``Either``。但記住我們說過``Functor``只能接受一個type constructor。這也是為什麼``(->)``不是``Functor``的一個instance，但``(->) r``則是。如果程式的語法允許的話，你也可以將``(->) r``寫成(r ->)。就如``(2+)``代表的其實是``(+) 2``。至於細節是如何呢？我們可以看看``Control.Monad.Instances``。

    我們通常說一個接受任何東西以及回傳隨便一個東西的函數型態是``a -> b``。``r -> a``是同樣意思，只是把符號代換了一下。

{{
instance Functor ((->) r) where  
    fmap f g = (\x -> f (g x))  
}}

如果語法允許的話，他可以被寫成

{{
instance Functor (r ->) where  
    fmap f g = (\x -> f (g x))  
}}

但其實是不允許的，所以我們必須寫成第一種的樣子。

首先我們來看看``fmap``的型態。他的型態是``fmap :: (a -> b) -> f a -> f b``。我們把所有的``f``在心裡代換成``(->) r``。則``fmap``的型態就變成``fmap :: (a -> b) -> ((->) r a) -> ((->) r b)``。接著我們把``(->) r a``跟``(->) r b``換成``r -> a``跟``r -> b``。則我們得到``fmap :: (a -> b) -> (r -> a) -> (r -> b)``。

從上面的結果看到將一個function map over一個function會得到另一個function，就如map over一個function到``Maybe``會得到一個``Maybe``，而map over一個function到一個list會得到一個list。而``fmap :: (a -> b) -> (r -> a) -> (r -> b)``告訴我們什麼？他接受一個從``a``到``b``的function，跟一個從``r``到``a``的function，並回傳一個從``r``到``b``的function。這根本就是function composition。把``r -> a``的輸出接到``a -> b``的輸入，的確是function composition在做的事。如果你再仔細看看instance的定義，會發現真的就是一個function composition。

{{
instance Functor ((->) r) where  
    fmap = (.)  
}}

這很明顯就是把``fmap``當composition在用。可以用``:m + Control.Monad.Instances``把模組裝載進來，並做一些嘗試。

{{
ghci> :t fmap (*3) (+100)  
fmap (*3) (+100) :: (Num a) => a -> a  
ghci> fmap (*3) (+100) 1  
303  
ghci> (*3) `fmap` (+100) $ 1  
303  
ghci> (*3) . (+100) $ 1  
303  
ghci> fmap (show . (*3)) (*100) 1  
"300"  
}}

我們呼叫``fmap``的方式是infix的方式，這跟``.``很像。在第二行，我們把``(*3)`` map over到``(+100)``上，這會回傳一個先把輸入值``(+100)``再``(*3)``的function，我們再用``1``去呼叫他。

到這邊為止盒子的比喻還適用嗎？如果你硬是要解釋的話還是解釋得通。當我們將``fmap (+3)`` map over ``Just 3``的時候，對於``Maybe``我們很容易把他想成是裝了值的盒子，我們只是對盒子裡面的值``(+3)``。但對於``fmap (*3) (+100)``呢？你可以把``(+100)``想成是一個裝了值的盒子。有點像把I/O action想成長了腳的盒子一樣。對``(+100)``使用``fmap (*3)``會產生另一個表現得像``(+100)``的function。只是在算出值之前，會再多計算``(*3)``。這樣我們可以看出來``fmap``表現得就像``.``一樣。

``fmap``等同於function composition這件事對我們來說並不是很實用，但至少是一個有趣的觀點。這也讓我們打開視野，看到盒子的比喻不是那麼恰當，functors其實比較像computation。function被map over到一個computation會產生經由那個function映射過後的computation。

[$img/lifter.png]

在我們繼續看``fmap``該遵守的規則之前，我們再看一次``fmap``的型態，他是``fmap :: (a -> b) -> f a -> f b``。很明顯我們是在討論Functor，所以為了簡潔，我們就不寫``(Functor f) =>``的部份。當我們在學curry的時候，我們說過Haskell的function實際上只接受一個參數。一個型態是``a -> b -> c``的函數實際上是接受``a``然後回傳``b -> c``，而``b -> c``實際上接受一個``b``然後回傳一個``c``。如果我們用比較少的參數呼叫一個函數，他就會回傳一個函數需要接受剩下的參數。所以``a -> b -> c``可以寫成``a -> (b -> c)``。這樣curry可以明顯一些。

同樣的，我們可以不要把``fmap``想成是一個接受function跟functor並回傳一個function的function。而是想成一個接受function並回傳一個新的function的function，回傳的function接受一個functor並回傳一個functor。他接受``a -> b``並回傳``f a -> f b``。這動作叫做lifting。我們用GHCI的``:t``來做的實驗。

{{
ghci> :t fmap (*2)  
fmap (*2) :: (Num a, Functor f) => f a -> f a  
ghci> :t fmap (replicate 3)  
fmap (replicate 3) :: (Functor f) => f a -> f [a]  
}}

``fmap (*2)``接受一個functor ``f``，並回傳一個基於數字的functor。那個functor可以是list，可以是``Maybe``，可以是``Either String``。``fmap (replicate 3)``可以接受一個基於任何型態的functor，並回傳一個基於list的functor。

    當我們提到functor over numbers的時候，你可以想像他是一個functor包含有許多數字在裡面。前面一種說法其實比較正確，但後面一種說法比較容易讓人理解。

這樣的觀察在我們只有綁定一個部份套用的函數，像是``fmap (++"!")``，的時候會顯得更清楚，

你可以把``fmap``想做是一個函數，他接受另一個函數跟一個functor，然後把函數對functor每一個元素做映射，或你可以想做他是一個函數，他接受一個函數並把他lift到可以在functors上面操作。兩種想法都是正確的，而且在Haskell中是等價。

``fmap (replicate 3) :: (Functor f) => f a -> f [a]``這樣的型態代表這個函數可以運作在任何functor上。至於確切的行為則要看究竟我們操作的是什麼樣的functor。如果我們是用``fmap (replicate 3)``對一個list操作，那我們會選擇``fmap``針對list的實作，也就是只是一個``map``。如果我們是碰到``Maybe a``。那他在碰到``Just``型態的時候，會對裡面的值套用``replicate 3``。而碰到``Nothing``的時候就回傳``Nothing``。

{{
ghci> fmap (replicate 3) [1,2,3,4]  
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]  
ghci> fmap (replicate 3) (Just 4)  
Just [4,4,4]  
ghci> fmap (replicate 3) (Right "blah")  
Right ["blah","blah","blah"]  
ghci> fmap (replicate 3) Nothing  
Nothing  
ghci> fmap (replicate 3) (Left "foo")  
Left "foo"  
}}


接下來我們來看看functor laws。一個東西要成為functor，必須要遵守某些定律。不管任何一個functor都被要求具有某些性質。他們必須是能被map over的。對他們呼叫``fmap``應該是要用一個函數map每一個元素，不多做任何事情。這些行為都被functor laws所描述。對於``Functor``的instance來說，總共兩條定律應該被遵守。不過他們不會在Haskell中自動被檢查，所以你必須自己確認這些條件。

functor law的第一條說明，如果我們對functor做map ``id``，那得到的新的functor應該要跟原來的一樣。如果寫得正式一點，他代表``fmap id = id``。基本上他就是說對functor呼叫``fmap id``，應該等同於對functor呼叫``id``一樣。畢竟``id``只是identity function，他只會把參數照原樣丟出。他也可以被寫成``\x -> x``。如果我們對functor的概念就是可以被map over的物件，那``fmap id = id``的性就顯而易見。

我們來看看這個定律的幾個案例：

{{
ghci> fmap id (Just 3)  
Just 3  
ghci> id (Just 3)  
Just 3  
ghci> fmap id [1..5]  
[1,2,3,4,5]  
ghci> id [1..5]  
[1,2,3,4,5]  
ghci> fmap id []  
[]  
ghci> fmap id Nothing  
Nothing  
}}

如果我們看看``Maybe``的``fmap``的實作，我們不難發現第一定律為何被遵守。

{{
instance Functor Maybe where  
    fmap f (Just x) = Just (f x)  
    fmap f Nothing = Nothing  
}}

我們可以想像在``f``的位置擺上``id``。我們看到``fmap id``拿到``Just x``的時候，結果只不過是``Just (id x)``，而``id``有只回傳他拿到的東西，所以可以知道``Just (id x)``等價於``Just x``。所以說我們可以知道對``Maybe``中的``Just``用``id``去做map over的動作，會拿回一樣的值。

而將``id`` map over ``Nothing``會拿回``Nothing``並不稀奇。所以從這兩個``fmap``的實作，我們可以看到的確``fmap id = id``有被遵守。


[^img/justice.png]


第二定律描述說先將兩個函數合成並將結果map over一個functor的結果，應該跟先將第一個函數map over一個functor，再將第二個函數map over那個functor的結果是一樣的。正式地寫下來的話就是``fmap (f . g) = fmap f . fmap g``。或是用另外一種寫法，對於任何一個functor F，下面這個式子應該要被遵守：``fmap (f . g) F = fmap f (fmap g F)``v


如果我們能夠證明某個型別遵守兩個定律，那我們就可以保證他跟其他functor對於映射方面都擁有相同的性質。我們知道如果對他用``fmap``，我們知道不會有除了mapping以外的事會發生，而他就僅僅會表現成某個可以被map over的東西。也就是一個functor。你可以再仔細檢視``fmap``對於某些型別的實作來了解第二定律。正如我們先前對``Maybe``檢視第一定律一般。

如果你需要的話，我們能在這邊演練一下``Maybe``是如何遵守第二定律的。首先``fmap (f . g)``來map over ``Nothing``的話，我們會得到``Nothing``。因為用任何函數來``fmap`` ``Nothing``的話都會回傳``Nothing``。如果我們``fmap f (fmap g Nothing)``，我們會得到``Nothing``。可以看到當面對``Nothing``的時候，``Maybe``很顯然是遵守第二定律的。
那對於``Just something``呢？如果我們使用``fmap (f . g) (Just x)``的話，從實作的程式碼中我可以看到``Just ((f . g ) x)``，也就是``Just (f (g x))``。如果我們使用``fmap f (fmap g (Just x))``的話我們可以從實作知道``fmap g (Just x)``會是``Just (g x)``。``fmap f (fmap g (Just x))``跟``fmap f (Just (g x))``相等。而從實作上這又會相等於``Just (f (g x))``。

如果你不太理解這邊的說明，別擔心。只要確定你了解什麼是函數合成就好。在多數的情況下你可以直覺地對應到這些型別表現得就像containers或函數一樣。或是也可以換種方法，只要多嘗試對型別中不同的值做操作你就可以看看型別是否有遵守定律。

我們來看一些經典的例子。這些型別建構子雖然是``Functor``的instance，但實際上他們並不是functor，因為他們並不遵守這些定律。我們來看看其中一個型別。

{{
data CMaybe a = CNothing | CJust Int a deriving (Show)      
}}

C這邊代表的是計數器。他是一種看起來像是``Maybe a``的型別，只差在``Just``包含了兩個field而不是一個。在``CJust``中的第一個field是``Int``，他是扮演計數器用的。而第二個field則為型別``a``，他是從型別參數來的，而他確切的型別當然會依據我們選定的``CMaybe a``而定。我們來對他作些操作來獲得些操作上的直覺吧。

{{
ghci> CNothing  
CNothing  
ghci> CJust 0 "haha"  
CJust 0 "haha"  
ghci> :t CNothing  
CNothing :: CMaybe a  
ghci> :t CJust 0 "haha"  
CJust 0 "haha" :: CMaybe [Char]  
ghci> CJust 100 [1,2,3]  
CJust 100 [1,2,3]  
}}


如果我們使用``CNothing``，就代表不含有field。如果我們用的是``CJust``，那第一個field是整數，而第二個field可以為任何型別。我們來定義一個``Functor``的instance，這樣每次我們使用``fmap``的時候，函數會被套用在第二個field，而第一個field會被加一。

{{
instance Functor CMaybe where  
    fmap f CNothing = CNothing  
    fmap f (CJust counter x) = CJust (counter+1) (f x)  
}}

這種定義方式有點像是``Maybe``的定義方式，只差在當我們使用``fmap``的時候，如果碰到的不是空值，那我們不只會套用函數，還會把計數器加一。我們可以來看一些範例操作。


{{
ghci> fmap (++"ha") (CJust 0 "ho")  
CJust 1 "hoha"  
ghci> fmap (++"he") (fmap (++"ha") (CJust 0 "ho"))  
CJust 2 "hohahe"  
ghci> fmap (++"blah") CNothing  
CNothing  
}}


這些會遵守functor laws嗎？要知道有不遵守的情形，只要找到一個反例就好了。


{{
ghci> fmap id (CJust 0 "haha")  
CJust 1 "haha"  
ghci> id (CJust 0 "haha")  
CJust 0 "haha"  
}}


我們知道functor law的第一定律描述當我們用``id``來map over一個functor的時候，他的結果應該跟只對functor呼叫``id``的結果一樣。但我們可以看到這個例子中，這對於``CMaybe``並不遵守。儘管他的確是``Functor`` typeclass的一個instace。但他並不遵守functor law因此不是一個functor。如果有人使用我們的``CMaybe``型別，把他當作functor用，那他就會期待functor laws會被遵守。但``CMaybe``並沒辦法滿足，便會造成錯誤的程式。當我們使用一個functor的時候，函數合成跟map over的先後順序不應該有影響。但對於``CMaybe``他是有影響的，因為他紀錄了被map over的次數。如果我們希望``CMaybe``遵守functor law，我們必須要讓``Int``欄位在做``fmap``的時候維持不變。


乍看之下functor laws看起來不是很必要，也容易讓人搞不懂，但我們知道如果一個型別遵守functor laws，那我們就能對他作些基本的假設。如果遵守了functor laws，我們知道對他做``fmap``不會做多餘的事情，只是用一個函數做映射而已。這讓寫出來的程式碼足夠抽象也容易擴展。因為我們可以用定律來推論型別的行為。


所有在標準函式庫中的``Functor``的instance都遵守這些定律，但你可以自己檢查一遍。下一次你定義一個型別為``Functor``的instance的時候，花點時間確認他確實遵守functor laws。一旦你操作過足夠多的functors時，你就會獲得直覺，知道他們會有什麼樣的性質跟行為。而且functor laws也會覺得顯而易見。但就算沒有這些直覺，你仍然可以一行一行地來找看看有沒有反例讓這些定律失效。


我們可以把functor看作輸出具有context的值。例如說``Just 3``就是輸出``3``，但他又帶有一個可能沒有值的context。``[1,2,3]``輸出三個值，``1``,``2``跟``3``，同時也帶有可能有多個值或沒有值的context。``(+3)``則會帶有一個依賴於參數的context。


如果你把functor想做是輸出值這件事，那你可以把map over一個functor這件事想成在functor輸出的後面再多加一層轉換。當我們做``fmap (+3) [1,2,3]``的時候，我們是把``(+3)``接到``[1,2,3]``後面，所以當我們檢視任何一個list的輸出的時候，``(+3)``也會被套用在上面。另一個例子是對函數做map over。當我們做``fmap (+3) (*3)``，我們是把``(+3)``這個轉換套用在``(*3)``後面。這樣想的話會很自然就會把``fmap``跟函數合成關聯起來（``fmap (+3) (*3)``等價於``(+3) . (*3)`，也等價於``\x -> ((x*3)+3)``），畢竟我們是接受一個函數``(*3)``然後套用``(+3)``轉換。最後的結果仍然是一個函數，只是當我們餵給他一個數字的時候，他會先乘上三然後做轉換加上三。這基本上就是函數合成在做的事。

==Applicative functors

[$img/present.png]

在這個章節中，我們會學到applicative functors，也就是加強版的functors，在Haskell中是用在``Control.Applicative``中的``Applicative``這個typeclass來定義的。

你還記得Haskell中函數預設就是Curried的，那代表接受多個參數的函數實際上是接受一個參數然後回傳一個接受剩餘參數的函數，以此類推。如果一個函數的型別是``a -> b -> c``，我們通常會說這個函數接受兩個參數並回傳``c``，但他實際上是接受``a``並回傳一個``b -> c``的函數。這也是為什麼我們可以用``(f x) y``的方式呼叫``f x y``。這個機制讓我們可以partially apply一個函數，可以用比較少的參數呼叫他們。可以做成一個函數再餵給其他函數。

到目前為止，當我們要對functor map over一個函數的時候，我們用的函數都是只接受一個參數的。但如果我們要map一個接受兩個參數的函數呢？我們來看幾個具體的例子。如果我們有``Just 3``然後我們做``fmap (*) (Just 3)``，那我們會獲得什麼樣的結果？從``Maybe``對``Functor``的instance實作來看，我們知道如果他是``Just something``，他會對在``Just``中的``something``做映射。因此當``fmap (*) (Just 3)``會得到``Just ((*) 3)``，也可以寫做``Just (* 3)``。我們得到了一個包在``Just``中的函數。

{{
ghci> :t fmap (++) (Just "hey")  
fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])  
ghci> :t fmap compare (Just 'a')  
fmap compare (Just 'a') :: Maybe (Char -> Ordering)  
ghci> :t fmap compare "A LIST OF CHARS"  
fmap compare "A LIST OF CHARS" :: [Char -> Ordering]  
ghci> :t fmap (\x y z -> x + y / z) [3,4,5,6]  
fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]  
}}

如果我們map ``compare``到一個包含許多字元的list呢？他的型別是``(Ord a) => a -> a -> Ordering``，我們會得到包含許多``Char -> Ordering``型別函數的list，因為``compare``被partially apply到list中的字元。他不是包含許多``(Ord a) => a -> Ordering``的函數，因為第一個``a``碰到的型別是``Char``，所以第二個``a``也必須是``Char``。


我們看到如何用一個多參數的函數來map functor，我們會得到一個包含了函數的functor。那現在我們能對這個包含了函數的functor做什麼呢？我們能用一個吃這些函數的函數來map over這個functor，這些在functor中的函數都會被當作參數丟給我們的函數。

{{
ghci> let a = fmap (*) [1,2,3,4]  
ghci> :t a  
a :: [Integer -> Integer]  
ghci> fmap (\f -> f 9) a  
[9,18,27,36]  
}}

但如果我們的有一個functor裡面是``Just (3 *)``還有另一個functor裡面是``Just 5``，但我們想要把第一個``Just (3 *)`` map over ``Just 5``呢？如果是普通的functor，那就沒救了。因為他們只允許map一個普通的函數。即使我們用``\f -> f 9``來map一個裝了很多函數的functor，我們也是使用了普通的函數。我們是無法單純用``fmap``來把包在一個functor的函數map另一個包在functor中的值。我們能用模式匹配``Just``來把函數從裡面抽出來，然後再map ``Just 5``，但我們是希望有一個一般化的作法，對任何functor都有效。

我們來看看``Applicative``這個typeclass。他位在``Control.Applicative``中，在其中定義了兩個函數``pure``跟``<*>``。他並沒有提供預設的實作，如果我們想使用他必須要為他們applicative functor的實作。typeclass定義如下：

{{
class (Functor f) => Applicative f where  
    pure :: a -> f a  
    (<*>) :: f (a -> b) -> f a -> f b  
}}

這簡簡單單的三行可以讓我們學到不少。首先來看第一行。他開啟了``Applicative``的定義，並加上class contraint。描述了一個型別構造子要是``Applicative``，他必須也是``Functor``。這就是為什麼我們說一個型別構造子屬於``Applicative``的話，他也會是``Functor``，因此我們能對他使用``fmap``。

第一個定義的是``pure``。他的型別宣告是``pure :: a -> f a``。``f``代表applicative functor的instance。由於Haskell有一個優秀的型別系統，其中函數又是將一些參數映射成結果，我們可以從型別宣告中讀出許多訊息。``pure``應該要接受一個值，然後回傳一個包含那個值的applicative functor。我們這邊是用盒子來作比喻，即使有一些比喻不完全符合現實的情況。儘管這樣，``a -> f a``仍有許多豐富的資訊，他確實告訴我們他會接受一個值並回傳一個applicative functor，裡面裝有結果。

對於``pure``比較好的書法是把一個普通值放到一個預設的context下，一個最小的context但仍然包含這個值。

``<*>``也非常有趣。他的型別是``f (a -> b) -> f a -> f b``。這有讓你聯想到什麼嗎？沒錯！就是``fmap :: (a -> b) -> f a -> f b``。他有點像加強版的``fmap``。然而``fmap``接受一個函數跟一個functor，然後套用functor之中的函數。``<*>``則是接受一個裝有函數的functor跟另一個functor，然後取出第一個functor中的函數將他對第二個functor中的值做map。

我們來看看``Maybe``的``Applicative``實作：

{{
instance Applicative Maybe where  
    pure = Just  
    Nothing <*> _ = Nothing  
    (Just f) <*> something = fmap f something  
}}

從class的定義我們可以看到``f``作為applicative functor會接受一個具體型別當作參數，所以我們是寫成``instance Applicative Maybe where``而不是寫成``instance Applicative (Maybe a) where``。


{{
ghci> Just (+3) <*> Just 9  
Just 12  
ghci> pure (+3) <*> Just 10  
Just 13  
ghci> pure (+3) <*> Just 9  
Just 12  
ghci> Just (++"hahah") <*> Nothing  
Nothing  
ghci> Nothing <*> Just "woot"  
Nothing  
}}


{{
ghci> pure (+) <*> Just 3 <*> Just 5  
Just 8  
ghci> pure (+) <*> Just 3 <*> Nothing  
Nothing  
ghci> pure (+) <*> Nothing <*> Just 5  
Nothing  
}}

[$img/whale.png]

{{
(<$>) :: (Functor f) => (a -> b) -> f a -> f b  
f <$> x = fmap f x  
}}

{{
ghci> (++) <$> Just "johntra" <*> Just "volta"  
Just "johntravolta"  
}}

{{
ghci> (++) "johntra" "volta"  
"johntravolta"  
}}


{{
instance Applicative [] where  
    pure x = [x]  
    fs <*> xs = [f x | f <- fs, x <- xs]  
}}

{{
ghci> pure "Hey" :: [String]  
["Hey"]  
ghci> pure "Hey" :: Maybe String  
Just "Hey"  
}}


{{
ghci> [(*0),(+100),(^2)] <*> [1,2,3]  
[0,0,0,101,102,103,1,4,9]  
}}


{{
ghci> [(+),(*)] <*> [1,2] <*> [3,4]  
[4,5,5,6,3,4,6,8]  
}}


{{
ghci> (++) <$> ["ha","heh","hmm"] <*> ["?","!","."]  
["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."] 
}}


{{
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]     
[16,20,22,40,50,55,80,100,110]     
}}


{{
ghci> (*) <$> [2,5,10] <*> [8,10,11]  
[16,20,22,40,50,55,80,100,110]  
}}

{{
ghci> filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]  
[55,80,100,110]  
}}

{{
instance Applicative IO where  
    pure = return  
    a <*> b = do  
        f <- a  
        x <- b  
        return (f x)  
}}





[^img/knight.png]


{{
myAction :: IO String  
myAction = do  
    a <- getLine  
    b <- getLine  
    return $ a ++ b  
}}


{{
myAction :: IO String  
myAction = (++) <$> getLine <*> getLine  
}}


{{
main = do  
    a <- (++) <$> getLine <*> getLine  
    putStrLn $ "The two lines concatenated turn out to be: " ++ a  
}}


{{
instance Applicative ((->) r) where  
    pure x = (\_ -> x)  
    f <*> g = \x -> f x (g x)  
}}


{{
ghci> (pure 3) "blah"  
3  
}}


{{
ghci> pure 3 "blah"  
3  
}}


{{
ghci> :t (+) <$> (+3) <*> (*100)  
(+) <$> (+3) <*> (*100) :: (Num a) => a -> a  
ghci> (+) <$> (+3) <*> (*100) $ 5  
508 
}}


{{
ghci> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5  
[8.0,10.0,2.5]  
}}

[$img/jazzb.png]

{{
instance Applicative ZipList where  
        pure x = ZipList (repeat x)  
        ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)  
}}


{{
ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100,100]  
[101,102,103]  
ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100..]  
[101,102,103]  
ghci> getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]  
[5,3,3,4]  
ghci> getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"  
[('d','c','r'),('o','a','a'),('g','t','t')]  
}}


{{
liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c  
liftA2 f a b = f <$> a <*> b  
}}

{{
ghci> fmap (\x -> [x]) (Just 4)  
Just [4]  
}}


{{
ghci> liftA2 (:) (Just 3) (Just [4])  
Just [3,4]  
ghci> (:) <$> Just 3 <*> Just [4]  
Just [3,4]  
}}


{{
sequenceA :: (Applicative f) => [f a] -> f [a]  
sequenceA [] = pure []  
sequenceA (x:xs) = (:) <$> x <*> sequenceA xs  
}}

{{
sequenceA :: (Applicative f) => [f a] -> f [a]  
sequenceA = foldr (liftA2 (:)) (pure [])  
}}


{{
ghci> sequenceA [Just 3, Just 2, Just 1]  
Just [3,2,1]  
ghci> sequenceA [Just 3, Nothing, Just 1]  
Nothing  
ghci> sequenceA [(+3),(+2),(+1)] 3  
[6,5,4]  
ghci> sequenceA [[1,2,3],[4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]  
[]  
}}


{{
ghci> map (\f -> f 7) [(>4),(<10),odd]  
[True,True,True]  
ghci> and $ map (\f -> f 7) [(>4),(<10),odd]  
True  
}}

{{
ghci> sequenceA [(>4),(<10),odd] 7  
[True,True,True]  
ghci> and $ sequenceA [(>4),(<10),odd] 7  
True  
}}

{{
ghci> sequenceA [[1,2,3],[4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> [[x,y] | x <- [1,2,3], y <- [4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> sequenceA [[1,2],[3,4]]  
[[1,3],[1,4],[2,3],[2,4]]  
ghci> [[x,y] | x <- [1,2], y <- [3,4]]  
[[1,3],[1,4],[2,3],[2,4]]  
ghci> sequenceA [[1,2],[3,4],[5,6]]  
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]  
ghci> [[x,y,z] | x <- [1,2], y <- [3,4], z <- [5,6]]  
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]  
}}


{{
ghci> sequenceA [getLine, getLine, getLine]  
heyh  
ho  
woo  
["heyh","ho","woo"]  
}}



==關鍵字"newtype"

[^img/maoi.png]

{{
ghci> [(+1),(*100),(*5)] <*> [1,2,3]  
[2,3,4,100,200,300,5,10,15]  
}}


{{
ghci> getZipList $ ZipList [(+1),(*100),(*5)] <*> ZipList [1,2,3]  
[2,200,15]  
}}


{{
data ZipList a = ZipList [a]      
}}

{{
data ZipList a = ZipList { getZipList :: [a] }      
}}

{{
newtype ZipList a = ZipList { getZipList :: [a] }      
}}

{{
data Profession = Fighter | Archer | Accountant  
  
data Race = Human | Elf | Orc | Goblin  

data PlayerCharacter = PlayerCharacter Race Profession  
}}

{{
newtype CharList = CharList { getCharList :: [Char] } deriving (Eq, Show)      
}}


{{
ghci> CharList "this will be shown!"  
CharList {getCharList = "this will be shown!"}  
ghci> CharList "benny" == CharList "benny"  
True  
ghci> CharList "benny" == CharList "oisters"  
False  
}}

{{
CharList :: [Char] -> CharList      
}}

{{
getCharList :: CharList -> [Char]      
}}


[$img/krakatoa.png]

{{
class Functor f where  
    fmap :: (a -> b) -> f a -> f b  
}}

{{
instance Functor Maybe where       
}}


{{
fmap :: (a -> b) -> Maybe a -> Maybe b      
}}

[$img/shamrock.png]

{{
newtype Pair b a = Pair { getPair :: (a,b) }      
}}


{{
instance Functor (Pair c) where  
    fmap f (Pair (x,y)) = Pair (f x, y)  
}}


{{
fmap :: (a -> b) -> Pair c a -> Pair c b      
}}


{{
class Functor f where  
    fmap :: (a -> b) -> f a -> f b  
}}

{{
ghci> getPair $ fmap (*100) (Pair (2,3))  
(200,3)  
ghci> getPair $ fmap reverse (Pair ("london calling", 3))  
("gnillac nodnol",3)  
}}


{{
ghci> undefined  
*** Exception: Prelude.undefined  
}}

{{
ghci> head [3,4,5,undefined,2,undefined]  
3  
}}

{{
data CoolBool = CoolBool { getCoolBool :: Bool }      
}}

{{
helloMe :: CoolBool -> String  
helloMe (CoolBool _) = "hello"  
}}

{{
type IntList = [Int]      
}}


{{
ghci> ([1,2,3] :: IntList) ++ ([1,2,3] :: [Int])  
[1,2,3,1,2,3]  
}}

{{
newtype CharList = CharList { getCharList :: [Char] }      
}}

==Monoids

[$img/pirateship.png]

{{
ghci> 4 * 1  
4  
ghci> 1 * 9  
9  
ghci> [1,2,3] ++ []  
[1,2,3]  
ghci> [] ++ [0.5, 2.5]  
[0.5,2.5]  
}}

{{
ghci> (3 * 2) * (8 * 5)  
240  
ghci> 3 * (2 * (8 * 5))  
240  
ghci> "la" ++ ("di" ++ "da")  
"ladida"  
ghci> ("la" ++ "di") ++ "da"  
"ladida"  
}}

{{
class Monoid m where  
    mempty :: m  
    mappend :: m -> m -> m  
    mconcat :: [m] -> m  
    mconcat = foldr mappend mempty  
}}


[$img/balloondog.png]


===List are monoids

{{
instance Monoid [a] where  
    mempty = []  
    mappend = (++)  
}}


{{
ghci> [1,2,3] `mappend` [4,5,6]  
[1,2,3,4,5,6]  
ghci> ("one" `mappend` "two") `mappend` "tree"  
"onetwotree"  
ghci> "one" `mappend` ("two" `mappend` "tree")  
"onetwotree"  
ghci> "one" `mappend` "two" `mappend` "tree"  
"onetwotree"  
ghci> "pang" `mappend` mempty  
"pang"  
ghci> mconcat [[1,2],[3,6],[9]]  
[1,2,3,6,9]  
ghci> mempty :: [a]  
[]  
}}

[^img/smug.png]

{{
ghci> "one" `mappend` "two"  
"onetwo"  
ghci> "two" `mappend` "one"  
"twoone"  
}}

{{
ghci> 0 + 4  
4  
ghci> 5 + 0  
5  
ghci> (1 + 3) + 5  
9  
ghci> 1 + (3 + 5)  
9  
}}


{{
newtype Product a =  Product { getProduct :: a }  
    deriving (Eq, Ord, Read, Show, Bounded)  
}}


{{
instance Num a => Monoid (Product a) where  
    mempty = Product 1  
    Product x `mappend` Product y = Product (x * y)  
}}


{{
ghci> getProduct $ Product 3 `mappend` Product 9  
27  
ghci> getProduct $ Product 3 `mappend` mempty  
3  
ghci> getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2  
24  
ghci> getProduct . mconcat . map Product $ [3,4,2]  
24  
}}


{{
ghci> getSum $ Sum 2 `mappend` Sum 9  
11  
ghci> getSum $ mempty `mappend` Sum 3  
3  
ghci> getSum . mconcat . map Sum $ [1,2,3]  
6  
}}


===Any and All

{{
newtype Any = Any { getAny :: Bool }  
    deriving (Eq, Ord, Read, Show, Bounded)  
}}


{{
instance Monoid Any where  
    mempty = Any False  
    Any x `mappend` Any y = Any (x || y)  
}}

{{
ghci> getAny $ Any True `mappend` Any False  
True  
ghci> getAny $ mempty `mappend` Any True  
True  
ghci> getAny . mconcat . map Any $ [False, False, False, True]  
True  
ghci> getAny $ mempty `mappend` mempty  
False  
}}

{{
newtype All = All { getAll :: Bool }  
        deriving (Eq, Ord, Read, Show, Bounded)  
}}

{{
instance Monoid All where  
        mempty = All True  
        All x `mappend` All y = All (x && y)  
}}

{{
ghci> getAll $ mempty `mappend` All True  
True  
ghci> getAll $ mempty `mappend` All False  
False  
ghci> getAll . mconcat . map All $ [True, True, True]  
True  
ghci> getAll . mconcat . map All $ [True, True, False]  
False  
}}


===The Ordering monoid

{{
ghci> 1 `compare` 2  
LT  
ghci> 2 `compare` 2  
EQ  
ghci> 3 `compare` 2  
GT  
}}


{{
instance Monoid Ordering where  
    mempty = EQ  
    LT `mappend` _ = LT  
    EQ `mappend` y = y  
    GT `mappend` _ = GT  
}}

[$img/bear.png]


{{
ghci> LT `mappend` GT  
LT  
ghci> GT `mappend` LT  
GT  
ghci> mempty `mappend` LT  
LT  
ghci> mempty `mappend` GT  
GT  
}}


{{
import Data.Monoid  
  
lengthCompare :: String -> String -> Ordering  
lengthCompare x y = (length x `compare` length y) `mappend`  
                    (x `compare` y)  
}}


{{
import Data.Monoid  
  
lengthCompare :: String -> String -> Ordering  
lengthCompare x y = (length x `compare` length y) `mappend`  
                    (vowels x `compare` vowels y) `mappend`  
                    (x `compare` y)  
    where vowels = length . filter (`elem` "aeiou")  
}}

{{
ghci> lengthCompare "zen" "anna"  
LT  
ghci> lengthCompare "zen" "ana"  
LT  
ghci> lengthCompare "zen" "ann"  
GT  
}}


===Maybe the monoid

{{
instance Monoid a => Monoid (Maybe a) where  
    mempty = Nothing  
    Nothing `mappend` m = m  
    m `mappend` Nothing = m  
    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)  
}}

{{
ghci> Nothing `mappend` Just "andy"  
Just "andy"  
ghci> Just LT `mappend` Nothing  
Just LT  
ghci> Just (Sum 3) `mappend` Just (Sum 4)  
Just (Sum {getSum = 7})  
}}


{{
newtype First a = First { getFirst :: Maybe a }  
    deriving (Eq, Ord, Read, Show) 
}}


{{
instance Monoid (First a) where  
    mempty = First Nothing  
    First (Just x) `mappend` _ = First (Just x)  
    First Nothing `mappend` x = x  
}}


{{
ghci> getFirst $ First (Just 'a') `mappend` First (Just 'b')  
Just 'a'  
ghci> getFirst $ First Nothing `mappend` First (Just 'b')  
Just 'b'  
ghci> getFirst $ First (Just 'a') `mappend` First Nothing  
Just 'a'  
}}


{{
ghci> getFirst . mconcat . map First $ [Nothing, Just 9, Just 10]  
Just 9  
}}

{{
ghci> getLast . mconcat . map Last $ [Nothing, Just 9, Just 10]  
Just 10  
ghci> getLast $ Last (Just "one") `mappend` Last (Just "two")  
Just "two" 
}}


===Using monoids to fold data structures

{{
import qualified Foldable as F      
}}

{{
ghci> :t foldr  
foldr :: (a -> b -> b) -> b -> [a] -> b  
ghci> :t F.foldr  
F.foldr :: (F.Foldable t) => (a -> b -> b) -> b -> t a -> b  
}}


{{
ghci> foldr (*) 1 [1,2,3]  
6  
ghci> F.foldr (*) 1 [1,2,3]  
6  
}}

{{
ghci> F.foldl (+) 2 (Just 9)  
11  
ghci> F.foldr (||) False (Just True)  
True 
}}



{{
data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)      
}}

{{
foldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m  
}}

{{
instance F.Foldable Tree where  
    foldMap f Empty = mempty  
    foldMap f (Node x l r) = F.foldMap f l `mappend`  
                                f x           `mappend`  
                                F.foldMap f r  
}}



[$img/accordion.png]


{{
testTree = Node 5  
            (Node 3  
             (Node 1 Empty Empty)  
             (Node 6 Empty Empty)  
            )  
            (Node 9  
             (Node 8 Empty Empty)  
             (Node 10 Empty Empty)  
            )  
}}


{{
ghci> F.foldl (+) 0 testTree  
42  
ghci> F.foldl (*) 1 testTree  
64800  
}}

{{
ghci> getAny $ F.foldMap (\x -> Any $ x == 3) testTree  
True 
}}

{{
ghci> getAny $ F.foldMap (\x -> Any $ x > 15) testTree  
False 
}}


{{
ghci> F.foldMap (\x -> [x]) testTree  
[1,3,6,5,8,9,10] 
}}
