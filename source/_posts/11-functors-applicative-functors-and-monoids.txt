=Functors, Applicative Functors與Monoids #functors-applicative-functors-and-monoids

Haskell的一些特色，像是純粹性，高階函數，algebraic data types，typeclasses，
這些讓我們可以從更高的角度來看到polymorphism這件事。
不像OOP當中需要從龐大的型態階層來思考。
我們只需要看看手邊的型態的行為，將他們跟適當地typeclass對應起來就可以了。
像``Int``的行為跟很多東西很像。
好比說他可以比較相不相等，可以從大到小排列，也可以將他們一一窮舉出來。

Typeclass的運用是很隨意的。
我們可以定義自己的資料型態，然後描述他可以怎樣被操作，跟typeclass關聯起來便定義了他的行為。
由於Haskell強大的型態系統，
這讓我們只要讀函數的型態宣告就可以知道很多資訊。
typeclass可以定義得很抽象很general。
我們之前有看過typeclass定義了可以比較兩個東西是否相等，或是定義了可以比較兩個東西的大小。
這些是既抽象但又描述簡潔的行為，
但我們不會認為他們有什麼特別之處，因為我們時常碰到他們。
最近我們看過了functor，基本上他們是一群可以被map over的物件。
這是其中一個例子能夠抽象但又漂亮地描述行為。
在這一章中，
我們會詳加闡述functors，
並會提到比較強一些的版本，也就是applicative functors。
我們也會提到monoids。


==溫習Functors

我們已經在之前的章節提到functors。
如果你還沒讀那個章節，
也許你應該先去看看。
或是你直接假裝你已經讀過了。

來快速複習一下：
Functors是可以被map over的物件，
像是lists，``Maybe``，trees等等。
在Haskell中我們是用``Functor``這個typeclass來描述他。
這個typeclass只有一個method，叫做``fmap``，
他的型態是``fmap :: (a -> b) ->  fa -> f b``。
這型態說明了如果給我一個從``a``映到``b``的函數，以及一個裝了``a``的盒子，
我會回給你一個裝了``b``的盒子。
就好像用這個函數將每個元素都轉成``b``一樣

    *給一點建議*。這盒子的比喻嘗試讓你抓到些functors是如何運作的感覺。在之後我們也會用相同的比喻來比喻applicative functors跟monads。在多數情況下這種比喻是恰當的，但不要過度引申，有些functors是不適用這個比喻的。一個比較正確的形容是functors是一個計算語境(computational context)。這個語境可能是這個computation可能帶有值，或是有可能會失敗(像``Maybe``跟``Either a``)，或是他可能有多個值(像lists)，等等。

如果一個type constructor要是``Functor``的instance，那他的kind必須是``* -> *``，
這代表他必須剛好接受一個type當作type parameter。
像是``Maybe``可以是Functor的一個instance，
因為他接受一個type parameter，來做成像是``Maybe Int``，或是``Maybe String``。
如果一個type constructor接受兩個參數，
像是``Either``，我們必須給他兩個type parameter。
所以我們不能這樣寫：``instance Functor Either where``，
但我們可以寫``instance Functor (Either a) where``，
如果我們把``fmap``限縮成只是``Either a``的，
那他的型態就是``fmap :: (b -> c) -> Either a b -> Either a c``。
就像你看到的，``Either a``的是固定的一部分，
因為``Either a``只恰好接受一個type parameter，
但``Either``則要接球兩個type parameters。
這樣fmap的型態變成``fmap :: (b -> c) -> Either b -> Either c``，這不太合理。

我們知道有許多型態都是``Functor``的instance，
像是``[]``，``Maybe``，``Either a``以及我們自己寫的``Tree``。
我們也看到了如何用一個函數map他們。
在這一章節，我們再多舉兩個例子，也就是``IO``跟``(->) r``。

如果一個值的型態是``IO String``，
他代表的是一個會被計算成String結果的I/O action。
我們可以用do syntax來把結果綁定到某個名稱。
我們之前把I/O action比喻做長了腳的盒子，會到真實世界幫我們取一些值回來。
我們可以檢視他們取了什麼值，
但一旦看過，我們必須要把值放回盒子中。
用這個比喻，``IO``的行為就像是一個functor。

我們來看看``IO``是怎麼樣的一個``Functor`` instance。
當我們``fmap``用一個function來map over I/O action時，
我們會想要拿回一個裝著已經用function映射過值的I/O action。

{{
instance Functor IO where
    fmap f action = do
        result <- action
        return (f result)
}}


==Applicative functors

==關鍵字"newtype"

==Monoids
