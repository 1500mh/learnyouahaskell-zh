=函數式地思考來解決問題 #functionally-solving-problems

在這一章中，我們會檢視幾個有趣的問題，並嘗試用函數式的方式來漂亮地解決他們。我們並不會介紹新的概念，我們只是練習我們剛學到的寫程式的技巧。每一節都會探討不同的問題。會先描述問題，然後用最好的方式解決他。


==運算逆波蘭表示法(Reverse Polish notation form)

我們在學校學習數學的時候，我們多半都是用中置(infix)的方式來寫數學式。例如說，我們會寫``10 - (4 + 3) * 2``。``+``, ``*``, ``-``是中置運算子(infix operators)。在Haskell中就像是``+``或``elem``一樣。這種寫法對於人類來說很容易閱讀與理解，但缺點是我們必須用括號來描述運算的優先順序。


逆波蘭表示法是另外一種數學式的描述方法。乍看之下顯得怪異，但他其實很容易理解並使用。因為我們不需要括弧來描述，也很容易放進計算機裡面運算。儘管現在的計算機都是用中置的方式讓你輸入，有些人仍堅持用RPN的計算機。前述的算式如果表達成RPN的話會是``10 4 3 + 2 * -``。我們要如何計算他的結果呢？可以想想堆疊，基本上你是從左向右閱讀算式。每當碰到一個數值，就把他堆上堆疊。當我們碰到一個運算子。就把兩個數值從堆疊上拿下來，用運算子運算兩個數值然後把結果推回堆疊中。當你消耗完整個算式的時候，而且假設你的算式是合法的，那你就應該只剩一個數值在堆疊中，

[^img/rpn.png]

我們再接著看``10 4 3 + 2 * -``。首先我們把``10``推到堆疊上，所以堆疊現在是``10``。下一個接著的輸入是``4``，我們也把他推上堆疊。堆疊的狀態便變成``10, 4``。接著也對下一個輸入``3``做同樣的事，所以堆疊變成``10, 4, 3``。然後便碰到了第一個運算子``+``。我們把堆疊最上層的兩個數值取下來（所以堆疊變成``10``）把兩個數值加起來然後推回堆疊上。堆疊的狀態便變成``10, 7``。我們再把輸入``2``推上堆疊，堆疊變成``10, 7, 2``。我們又碰到另一個運算子，所以把``7``跟``2``取下，把他們相乘起來然後推回堆疊上。``7``跟``2``相乘的結果是``14``，所以堆疊的狀態是``10, 14``。最後我們碰到了``-``。我們把``10``跟``14``取下，將他們相減然後推回堆疊上。所以現在堆疊的狀態變成``-4``。而我們已經把所有數值跟運算子的消耗完了，所以``-4``便是我們的結果。


現在我們知道我們如何手算RPN運算式了，接下來可以思考一下我們寫一個Haskell的函數，當他接到一個RPN運算式，像是``"10 4 3 + 2 * -"``時，他可以給出結果。


這個函數的型別會是什麼樣呢？我們希望他接受一個字串當作參數，並產出一個數值作為結果。所以應該會是``solveRPN :: (Num a) => String -> a``。


    小建議：在你去實作函數之前，先想一下你會怎麼宣告這個函數的型別能夠幫助你釐清問題。在Haskell中由於我們有夠強的型別系統，光從函數的宣告就可以得到許多資訊。

[^img/calculator.png]

當我們要實作一個問題的解法時，你可以先動手一步一步解看看，嘗試從裡面得到一些靈感。我們這邊把每一個用空白隔開的數值或運算子都當作獨立的一項。所以把``"10 4 3 + 2 * -"``這樣一個字串斷成一串list ``["10","4","3","+","2","*","-"]`` 應該會有幫助。


接下來我們要如何應用這個斷好的list呢？我們從左至右來走一遍，並保存一個工作用的堆疊。這樣有讓你想到些什麼可以用的嗎？沒錯，在``folds``的那一章裡面，我們提到基本上當你需要從左至右或由右至左走過一遍list的時候並產生些結果的時候。我們都能用fold來實作他。


在這個case中由於我們是從左邊走到右邊，所以我們採取left fold。accumulator則是選用堆疊，而fold的結果也會是一個堆疊，只是裡面只有一個元素而已。


另外要多考慮一件事是我們用什麼來代表我們的堆疊？我們可以用list來代替，list的head就可以當作是堆疊的頂端。畢竟要把一個元素加到list的head要比加到最後要有效率多。所以如果我們有一個堆疊，裡面有``10, 4, 3``，那我們可以用``[3,4,10]``來代表他。


現在我們有了足夠的資訊來寫出我們的函數。他會接受一個字串``"10 4 3 + 2 * -"``，隨即用``words``來斷成list ``["10","4","3","+","2","*","-"]``。接下來我們做一個left fold來產生出只有一個元素的堆疊，也就是``[-4]``。我們把這個元素從list取出便是最後的結果。

來看看我們的實作：

{{
import Data.List  
  
solveRPN :: (Num a) => String -> a  
solveRPN expression = head (foldl foldingFunction [] (words expression))  
    where   foldingFunction stack item = ...  
}}

我們接受一個運算式並把他斷成一串List。然後我們用一個folding函數來fold這串list。注意到我們用``[]``來當作起始的accumulator。這個accumulator就是我們的堆疊，所以``[]``代表一個空的堆疊。在運算之後我們得到一個只有一個元素的堆疊，我們呼叫``head``來取出他並用``read``來轉換他。

所以我們現在只缺一個接受堆疊的folding函數，像是可以接受``[4,10]``跟``"3"``，然後得到``[3,4,10]``。如果是``[4,10]``跟``"*"``，那就會得到``[40]``。但在實作之前，我們先把我們的函數改寫成point-free style，這樣可以省下許多括號。

{{
import Data.List  
  
solveRPN :: (Num a) => String -> a  
solveRPN = head . foldl foldingFunction [] . words  
      where   foldingFunction stack item = ...  
}}

看起來好多了。我們的folding函數會接受一個堆疊、新的項，並回傳一個新的堆疊。我們使用模式匹配的方式來取出堆疊最上層的元素，然後對``"*"``跟``"-"``做匹配。

{{
solveRPN :: (Num a, Read a) => String -> a  
solveRPN = head . foldl foldingFunction [] . words  
    where   foldingFunction (x:y:ys) "*" = (x * y):ys  
            foldingFunction (x:y:ys) "+" = (x + y):ys  
            foldingFunction (x:y:ys) "-" = (y - x):ys  
            foldingFunction xs numberString = read numberString:xs  
}}

我們用展開成四個模式匹配。模式會從第一個開始嘗試匹配。所以folding函數會看看目前的項是否是``"*"``。如果是，那就會將``[3,4,9,3]``的頭兩個元素綁定到``x``，``y``兩個名稱。所以``x``會是``3``而``y``等於``4``。``ys``便會是``[9,3]``。他會回傳一個list，只差在``x``跟``y``相乘的結果為第一個元素。也就是說會把最上層兩個元素取出，相乘後再放回去。如果第一個元素不是``"*"``，那模式匹配就會比對到``"+"``，以此類推。

如果項並未匹配到任何一個運算子，那我們就會假設這個字串是一個數值。如果他是一個數值，我們會用``read``來把字串轉換成數值。並把這個數值推到堆疊上。

另外注意到我們加了``Read a``這像class constraint，畢竟我們要使用到``read``來轉換成數值。所以我們必須要宣告成他要屬於``Num``跟``Read``兩種typeclass。（譬如說``Int``,``Float``等）

我們是從左至右走過``["2","3","+"]``。一開始堆疊的狀態是``[]``。首先他會用``[]``跟``"2"``來餵給folding函數。由於此項並不是一個運算子。他會用``read``讀取後加到``[]``的開頭。所以堆疊的狀態變成``[2]``。接下來就是用``[2]``跟``["3"]``來餵給folding函數，而得到``[3,2]``。最後再用``[3,2]``跟``"+"``來呼叫folding函數。這會堆疊頂端的兩個數值，加起來後推回堆疊。最後堆疊變成``[5]``，這就是我們回傳的數值。

我們來試試看我們新寫的函數：


{{
ghci> solveRPN "10 4 3 + 2 * -"  
-4  
ghci> solveRPN "2 3 +"  
5  
ghci> solveRPN "90 34 12 33 55 66 + * - +"  
-3947  
ghci> solveRPN "90 34 12 33 55 66 + * - + -"  
4037  
ghci> solveRPN "90 34 12 33 55 66 + * - + -"  
4037  
ghci> solveRPN "90 3 -"  
87  
}}

看起來運作良好。這個函數有一個特色就是他很容易改寫來支持額外的運算子。他們也不一定要是二元運算子。例如說我們可以寫一個運算子叫做``"log"``，他會從堆疊取出一個數值算出他的log後推回堆疊。我們也可以用三元運算子來從堆疊取出三個數值，並把結果放回堆疊。甚至是像是``"sum"``這樣的運算子，取出所有數值並把他們的和推回堆疊。


我們來改寫一下我們的函數讓他多支援幾個運算子。為了簡單起見，我們改寫宣告讓他回傳``Float``型別。

{{
import Data.List  
  
solveRPN :: String -> Float  
solveRPN = head . foldl foldingFunction [] . words  
where   foldingFunction (x:y:ys) "*" = (x * y):ys  
        foldingFunction (x:y:ys) "+" = (x + y):ys  
        foldingFunction (x:y:ys) "-" = (y - x):ys  
        foldingFunction (x:y:ys) "/" = (y / x):ys  
        foldingFunction (x:y:ys) "^" = (y ** x):ys  
        foldingFunction (x:xs) "ln" = log x:xs  
        foldingFunction xs "sum" = [sum xs]  
        foldingFunction xs numberString = read numberString:xs  
}}

看起來不錯，沒有疑問地``/``是除法而``**``是取exponential。至於log運算子，我們只需要模式匹配一個元素，畢竟log只需要一個元素。而sum運算子，我們只回傳一個僅有一個元素的堆疊，包含了所有元素的和。

{{
ghci> solveRPN "2.7 ln"  
0.9932518  
ghci> solveRPN "10 10 10 10 sum 4 /"  
10.0  
ghci> solveRPN "10 10 10 10 10 sum 4 /"  
12.5  
ghci> solveRPN "10 2 ^"  
100.0  
}}

由於``read``知道如何轉換浮點數，我們也可在運算適中使用他。

{{
ghci> solveRPN "43.2425 0.5 ^"  
6.575903  
}}

有這樣一個容易拓展到浮點數而且動到的程式碼又在十行以內的函數，我想是非常棒的。


有一件事要留意的是這個函數對於錯誤處理並不好。當我們碰到非法輸入的時候，他就會直接當掉。之後我們碰到Monad的時候我們會寫一個容錯的版本，他的型別會是``solveRPN :: String -> Maybe Float``。當然我們現在也可以寫一個，不過那會有點麻煩，因為會有一大堆檢查``Nothing``的動作。如果你希望挑戰的話，也可以盡管嘗試。（提示：你可以用``reads``來看看一次read是否會成功）


==路徑規劃

我們接下來的問題是：你的飛機剛剛降落在英格蘭的希思羅機場。你接下來有一個會議，你租了一台車希望盡速從機場前往倫敦市中心。

從希思羅機場到倫敦有兩條主要道路，他們中間有很多小路連接彼此。如果你要走小路的話都會花掉一定的時間。你的問題就是要選一條最佳路徑讓你可以盡快前往倫敦。你從圖的最左邊出發，中間可能穿越小路來前往右邊。

[img/roads.png]


{{
50  
10  
30  
5  
90  
20  
40  
2  
25  
10  
8  
0  
}}


{{
data Node = Node Road Road | EndNode Road  
data Road = Road Int Node 
}}


{{
data Node = Node Road (Maybe Road)  
data Road = Road Int Node  
}}


{{
data Section = Section { getA :: Int, getB :: Int, getC :: Int } deriving (Show)  
type RoadSystem = [Section]  
}}


{{
heathrowToLondon :: RoadSystem  
heathrowToLondon = [Section 50 10 30, Section 5 90 20, Section 40 2 25, Section 10 8 0]  
}}

{{
data Label = A | B | C deriving (Show)  
type Path = [(Label, Int)] 
}}

{{
[(B,10),(C,30),(A,5),(C,20),(B,2),(B,8)]      
}}


{{
roadStep :: (Path, Path) -> Section -> (Path, Path)  
roadStep (pathA, pathB) (Section a b c) =   
    let priceA = sum $ map snd pathA  
        priceB = sum $ map snd pathB  
        forwardPriceToA = priceA + a  
        crossPriceToA = priceB + b + c  
        forwardPriceToB = priceB + b  
        crossPriceToB = priceA + a + c  
        newPathToA = if forwardPriceToA <= crossPriceToA  
                        then (A,a):pathA  
                        else (C,c):(B,b):pathB  
        newPathToB = if forwardPriceToB <= crossPriceToB  
                        then (B,b):pathB  
                        else (C,c):(A,a):pathA  
    in  (newPathToA, newPathToB)  
}}



{{
ghci> roadStep ([], []) (head heathrowToLondon)  
([(C,30),(B,10)],[(B,10)])  
}}


{{
optimalPath :: RoadSystem -> Path  
optimalPath roadSystem = 
    let (bestAPath, bestBPath) = foldl roadStep ([],[]) roadSystem  
    in  if sum (map snd bestAPath) <= sum (map snd bestBPath)  
                then reverse bestAPath  
                else reverse bestBPath  
}}


{{
ghci> optimalPath heathrowToLondon  
[(B,10),(C,30),(A,5),(C,20),(B,2),(B,8),(C,0)]  
}}


{{
groupsOf :: Int -> [a] -> [[a]]  
groupsOf 0 _ = undefined  
groupsOf _ [] = []  
groupsOf n xs = take n xs : groupsOf n (drop n xs)
}}


{{
import Data.List  
  
main = do  
    contents <- getContents  
    let threes = groupsOf 3 (map read $ lines contents)  
        roadSystem = map (\[a,b,c] -> Section a b c) threes  
        path = optimalPath roadSystem  
        pathString = concat $ map (show . fst) path  
        pathPrice = sum $ map snd path  
    putStrLn $ "The best path to take is: " ++ pathString  
    putStrLn $ "The price is: " ++ show pathPrice  
}}


{{
50  
10  
30  
5  
90  
20  
40  
2  
25  
10  
8  
0  
}}



{{
$ cat paths.txt | runhaskell heathrow.hs  
The best path to take is: BCACBBC  
The price is: 75  
}}
