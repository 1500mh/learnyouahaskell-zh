=再來看看更多Monad #for-a-few-monads-more
我們已經看過Monad是如何接受具有context的值，並如何用函數操作他們。
還有如何用``>>=``跟``do``來減輕我們對context的關注，集中精神在value本身。

我們也看過了``Maybe``是如何把值加上一個可能會失敗的context。
我們學習到List Monad是如何加進多重結果的context。
我們也了解``IO`` Monad如何運作，而且我們在知道什麼是Monad之前就已經知道他了。

在這個章節，我們會介紹一些其他的Monad。
他們可以把值變成monadiv value，因此可以讓我們的程式更簡潔清晰。
多見識幾個Monad也可以敏銳我們對Monad的直覺。

我們即將要介紹的Monad都包含在``mtl``這個套建中。
一個Haskell package包含了一堆模組。
而``mtl``已經包含在Haskell Platform中，所以你可能不用另外安裝。
要檢查你有沒有這套件，你可以下``ghc-pkg list``。
這會列出你已經安裝的套件，其中應該包含``mtl``後面接著對應的版號。


==你所不知道的Writer Monad
我們已經看過``Maybe``, list以及``IO`` Monad。
現在我們要來看看``Writer`` Monad。

相對於``Maybe``是加入可能失敗的context，list是加入non-deterministic的context，
``Writer``則是加進一個附加值的context，好比log一般。
``Writer``可以讓我們在計算的同時蒐集所有log紀錄，並匯集成一個log並附加在結果上。

例如我們想要附加一個String好說明我們的值在幹麼（有可能是為了除錯）。
想像有一個函數接受一個代表幫派人數的數字，然後會回傳值告訴我們這是否算是一個龐大的幫派：

{{
isBigGang :: Int -> Bool  
isBigGang x = x > 9  
}}

現在我們希望他不只是回傳``True``或``False``，我們還希望他能夠多回傳一個字串代表log。
這很容易，只要多加一個``String``在``Bool``旁邊就好了。

{{
isBigGang :: Int -> (Bool, String)  
isBigGang x = (x > 9, "Compared gang size to 9.")  
}}

我們現在回傳了一個Tuple，第一個元素是原來的布林值，第二個元素是一個String。
現在我們的值有了一個context。

{{
ghci> isBigGang 3  
(False,"Compared gang size to 9.")  
ghci> isBigGang 30  
(True,"Compared gang size to 9.")  
}}

到目前為止都還不錯，``isBigGang``回傳一個值跟他的context。
對於正常的數值來說這樣的寫法都能運作良好。
但如果我們想要把一個已經具有context的值，像是``(3, "Smallish gang.")``，餵給``isBigGang``呢？
我們又面對了同樣的問題：
如果我們有一個能接受正常數值並回傳一個具有context值的function，
那我們要如何餵給他一個具有context的值？

當我們在研究``Maybe`` monad的時候，我們寫了一個``applyMaybe``。
他接受一個``Maybe a``值跟一個``a -> Maybe b``型態的函數，
他會把``Maybe a``餵給這個function，即便這個function其實是接受``a``而非``Maybe a``。
``applyMaybe``有針對這樣的context做處裡，也就是會留意有可能發生的失敗情況。
但在``a -> Maybe b``裡面，我們可以只專心處裡正常數值即可。
因為``applyMaybe`` (之後變成了``>>=``)會幫我們處裡需要檢查``Nothing``或``Just``的情況。

我們再來寫一個接受附加log值的函數，
也就是``(a, String)``型態的值跟``a -> (b, String)``型態的函數。
我們稱呼這個函數為``applyLog``。
這個函數有的context是附加log值，而不是一個可能會失敗的context，
因此``applyLog``會確保原有的log被保留，並附上從函數產生出的新的log。
這邊我們來看一下實做：

{{
applyLog :: (a,String) -> (a -> (b,String)) -> (b,String)  
applyLog (x,log) f = let (y,newLog) = f x in (y,log ++ newLog)  
}}

當我們想把一個具有context的值餵給一個函數的時候，
我們會嘗試把值跟他的context分開，然後把值餵給函數再重新接回context。
在``Maybe`` monad的情況，我們檢查值是否為``Just x``，如果是，便將``x``餵給函數。
而在log的情況，我們知道pair的其中一個component是log而另一個是值。
所以我們先取出值``x``，將``f`` apply到``x``，便獲取``(y,newLog)``，
其中``y``是新的值而``newLog``則是新的log。
但如果我們回傳``newLog``，舊的log便不會包含進去，
所以我們要回傳的是``(y, log ++ newLog)``。
我們用``++``來把新的log接到舊的上面。

來看看``applyLog``運作的情形：

{{
ghci> (3, "Smallish gang.") `applyLog` isBigGang  
(False,"Smallish gang.Compared gang size to 9")  
ghci> (30, "A freaking platoon.") `applyLog` isBigGang  
(True,"A freaking platoon.Compared gang size to 9")  
}}

跟之前的結果很像，只差在我們多了伴隨產生的log。
再來多看幾個例子：

{{
ghci> ("Tobin","Got outlaw name.") `applyLog` (\x -> (length x, "Applied length."))  
(5,"Got outlaw name.Applied length.")  
ghci> ("Bathcat","Got outlaw name.") `applyLog` (\x -> (length x, "Applied length"))  
(7,"Got outlaw name.Applied length")  
}}

可以看到在lambda裡面``x``只是個正常的字串而不是tuple，且``applyLog``幫我們處裡掉附加log的動作。

*Monoids的好處*

    請確定你了解什麼是Monoids。

到目前為止``applyLog``接受``(a,String)``型態的值，
但為什麼log一定要是``String``呢？
我們使用``++``來附加新的log，
難道``++``並不能運作在任何形式的list，而一定要限制我們在``String``上呢？
我們當然可以擺脫``String``，
我們可以如下改變他的型態：

{{
applyLog :: (a,[c]) -> (a -> (b,[c])) -> (b,[c])      
}}

我們用一個List來代表Log。
包含在List中的元素型態必須跟原有的List跟回傳的List型態相同，
否則我們沒辦法用``++``來把他們接起來。

這能夠運作在bytestring上嗎？絕對沒問題。
只是我們現在的型態只對List有效。
我們必須要另外做一個bytestring版本的``applyLog``。
但我們注意到List跟bytestring都是monoids。
因此他們都是``Monoid`` type class的instance，
那代表他們都有實做``mappend``。
對List以及bytestring而言，``mappend``都是拿來串接的。

{{
ghci> [1,2,3] `mappend` [4,5,6]  
[1,2,3,4,5,6]  
ghci> B.pack [99,104,105] `mappend` B.pack [104,117,97,104,117,97]  
Chunk "chi" (Chunk "huahua" Empty)  
}}

修改後我們的``applyLog``可以運作在任何monoid上。
我們必須要修改型態宣告來表示這件事，同時也要在實做中把``++``改成``mappend``：

{{
applyLog :: (Monoid m) => (a,m) -> (a -> (b,m)) -> (b,m)  
applyLog (x,log) f = let (y,newLog) = f x in (y,log `mappend` newLog)  
}}

由於現在包含的值可以是任何monoid，
我們不再需要把tuple想成包含一個值跟對應的log，
我們可以想成他包含一個值跟一個對應的monoid。
舉例來說，
可以說我們有一個tuple包含一個產品名稱跟一個符合monoid特性的產品價格。
我們可以定義一個``Sum``的newtype來保證我們在操作產品的時候也會把價錢跟著加起來。

{{
import Data.Monoid  
  
type Food = String  
type Price = Sum Int  

addDrink :: Food -> (Food,Price)  
addDrink "beans" = ("milk", Sum 25)  
addDrink "jerky" = ("whiskey", Sum 99)  
addDrink _ = ("beer", Sum 30)  
}}

我們用string來代表食物，用``newtype``重新定義``nInt``為``Sum``，
來追蹤總共需要花多少錢。
可以注意到我們用``mappend``來操作``Sum``的時候，價錢會被一起加起來。

{{
ghci> Sum 3 `mappend` Sum 9  
Sum {getSum = 12}  
}}

``addDrink``的實做很簡單，
如果我們想吃豆子，他會回傳``"milk"``以及伴隨的``Sum 25``，
同樣的如果我們要吃"jerky"，他就會回傳"whiskey"，
要吃其他東西的話，就會回傳"beer"。
乍看之下這個函數沒什麼特別，
但如果用``applyLog``的話就會有趣些。

{{
ghci> ("beans", Sum 10) `applyLog` addDrink  
("milk",Sum {getSum = 35})  
ghci> ("jerky", Sum 25) `applyLog` addDrink  
("whiskey",Sum {getSum = 124})  
ghci> ("dogmeat", Sum 5) `applyLog` addDrink  
("beer",Sum {getSum = 35})  
}}

牛奶價值``25``美分，但如果我們也吃了價值``10``美分的豆子的話，
總共需要付``35``美分。
這樣很清楚地展示了伴隨的值不一定需要是log，他可以是任何monoid。
至於兩個值要如何結合，那要看monoid中怎麼定義。
當我們需要的是log的時候，他們是串接，
但這個case裡面，數字是被加起來。

由於``addDrink``回傳一個``(Food,Price)``，
我們可以再把結果重新餵給``addDrink``，
這可以很容易告訴我們總共喝了多少錢：

{{
ghci> ("dogmeat", Sum 5) `applyLog` addDrink `applyLog` addDrink  
("beer",Sum {getSum = 65})  
}}

將狗食跟30美分的啤酒加在一起會得到``("beer", Sum 35)``。
如果我們用``applyLog``將上面的結果再餵給``addDrink``，
我們會得到``("beer", Sum 65)``這樣的結果。


*The Writer type*

我們認識了一個附加monoid的值其實表現出來的是一個monad，
我們來再來看看其他類似的``Monad`` instance。
``Control.Monad.Writer``這模組含有``Writer w a``的一個型態，
裏面定義了他``Monad``的instance，
還有一些操作這些值的函數。

首先，我們來看一下型態。
要把一個monoid附加給一個值，只需要定義一個tuple就好了。
``Writer w a``這型態其實是一個``newtype`` wrapper。
他的定義很簡單：

{{
newtype Writer w a = Writer { runWriter :: (a, w) }      
}}

他包在一個``newtype``裏面，並且可以是一個``Monad``的instance，
而且這樣定義的好處是可以跟單純tuple的型態區分開來。
``a``這個型態參數代表是包含的值的型態，而``w``則是附加的monoid的型態。

他``Monad`` instance的定義如下：

{{
instance (Monoid w) => Monad (Writer w) where  
    return x = Writer (x, mempty)  
    (Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')  
}}

首先，我們來看看``>>=``。
他的實作基本上就是``applyLog``，
只是我們的tuple現在是包在一個``Writer``的``newtype``中，
我們可以用pattern matching的方式把他給unwrap。
我們將``x``餵給``f``。
這會回給我們``Writer w a``。
接著可以用``let`` expression來做pattern matching。
把結果綁定到``y``這個名字上，
然後用``mappend``來結合舊的monoid值跟新的monoid值。
最後把結果跟monoid值用``Writer`` constructor包起來，
形成我們最後的``Writer`` value。


那``return``呢？
回想``return``的作用是接受一個值，並回傳一個具有意義的最小context來裝我們的值。
那究竟什麼樣的context可以代表我們的``Writer``呢？
如果我們希望monoid值所造成的影響愈小愈好，
那``mempty``是個合理的選擇。
``mempty``是被當作identity monoid value，
像是``""``或``Sum 0``，或是空的bytestring。
當我們對``mempty``用``mappend``跟其他monoid值結合，結果會是其他的monoid值。
所以如果我們用``return``來做一個``Writer``，然後用``>>=``來餵給其他的函數，
那函數回傳的便是算出來的monoid。
下面我們試著用``return``搭配不同context來回傳``3``：

{{
ghci> runWriter (return 3 :: Writer String Int)  
(3,"")  
ghci> runWriter (return 3 :: Writer (Sum Int) Int)  
(3,Sum {getSum = 0})  
ghci> runWriter (return 3 :: Writer (Product Int) Int)  
(3,Product {getProduct = 1})  
}}

因為``Writer``並沒有定義成``Show``的instance，
我們必須用``runWriter``來把我們的``Writer``轉成正常的tuple。
對於``String``，monoid的值就是空字串。
而對於``Sum``來說則是``0``，因為``0``加上其他任何值都會是對方。
而對``Product``來說，則是``1``。

這裡的``Writer`` instance並沒有定義``fail``，
所以如果pattern matching失敗的話，
就會呼叫``error``。


*Using do notation with Writer*

既然我們定義了``Monad``的instance，
我們自然可以用``do``串接``Writer``型態的值。
這在我們需要對一群``Writer``型態的值做處理時顯得特別方便。
就如其他的monad，
我們可以把他們當作具有context的值。
在現在這個case中，
所有的monoid的值都會用``mappend``來連接起來並得到最後的結果。
這邊有一個簡單的範例，我們用``Writer``來相乘兩個數。

{{
import Control.Monad.Writer  
  
logNumber :: Int -> Writer [String] Int  
logNumber x = Writer (x, ["Got number: " ++ show x])  
  
multWithLog :: Writer [String] Int  
multWithLog = do  
    a <- logNumber 3  
    b <- logNumber 5  
    return (a*b)  
}}

``logNumber``接受一個數並把這個數做成一個``Writer``。
我們再用一串string來當作我們的monoid值，
每一個數都跟著一個只有一個元素的list，說明我們只有一個數。
``multWithLog``式一個``Writer``，
他將``3``跟``5``相乘並確保相乘的紀錄有寫進最後的log中。
我們用``return``來做成``a*b``的結果。
我們知道``return``會接受某個值並加上某個最小的context，
我們可以確定他不會多添加額外的log。
如果我們執行程式會得到：

{{
ghci> runWriter multWithLog  
(15,["Got number: 3","Got number: 5"])  
}}

有時候我們就是想要在某個時間點放進某個Monoid value。
``tell``正是我們需要的函數。
他實作了``MonadWriter``這個type class，而且在當``Writer``用的時候也能接受一個monoid value，
好比說``["This is going on"]``。
我們能用他來把我們的monoid value接到任何一個dummy value ``()``上來形成一個Writer。
當我們拿到的結果是``()``的時候，我們不會把他綁定到變數上。
來看一個``multWithLog``的範例：

{{
multWithLog :: Writer [String] Int  
multWithLog = do  
    a <- logNumber 3  
    b <- logNumber 5  
    tell ["Gonna multiply these two"]  
    return (a*b)  
}}

``return (a*b)``是我們的最後一行，
還記得在一個``do``中的最後一行代表整個``do``的結果。
如果我們把``tell``擺到最後，
則``do``的結果則會是``()``。
我們會因此丟掉乘法運算的結果。
除此之外，log的結果是不變的。

{{
ghci> runWriter multWithLog  
(15,["Got number: 3","Got number: 5","Gonna multiply these two"])  
}}


*Adding logging to programs*
歐幾里得算法是找出兩個數的最大公因數。
Haskell已經提供了``gcd``的函數，
但我們來實作一個具有log功能的gcd：

{{
gcd' :: Int -> Int -> Int  
gcd' a b   
    | b == 0    = a  
    | otherwise = gcd' b (a `mod` b)  
}}

演算法的內容很簡單。
首先他檢查第二個數字是否為零。
如果是零，那就回傳第一個數字。
如果不是，那結果就是第二個數字跟將第一個數字除以第二個數字的餘數兩個數字的最大公因數。
舉例來說，
如果我們想知道8跟3的最大公因數，首先可以注意到3不是0。
所以我們要求的是3跟2的最大公因數(8除以3餘二)。
接下去我可以看到2不是0，所以我們要再找2跟1的最大公因數。
同樣的，第二個數不是0，所以我們再找1跟0的最大公因數。
最後第二個數終於是0了，所以我們得到最大公因數是1。

{{
ghci> gcd' 8 3  
1  
}}

答案真的是這樣。接著我們想加進context，
context會是一個monoid value並且像是一個log一樣。
就像之前的範例，我們用一串string來當作我們的monoid。
所以``gcd'``會長成這樣：

{{
gcd' :: Int -> Int -> Writer [String] Int  
}}

而他的程式碼會像這樣：

{{
import Control.Monad.Writer  
  
gcd' :: Int -> Int -> Writer [String] Int  
gcd' a b  
  | b == 0 = do  
      tell ["Finished with " ++ show a]  
      return a  
  | otherwise = do  
      tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]  
      gcd' b (a `mod` b)  
}}

這個函數接受兩個``Int``並回傳一個``Writer [String] Int``，
也就是說是一個有log context的``Int``。
當``b``等於``0``的時候，
我們用一個``do``來組成一個``Writer``的值。
我們先用``tell``來寫入我們的log，然後用``return``來當作``do``的結果。
當然我們也可以這樣寫：

{{
Writer (a, ["Finished with " ++ show a])  
}}

但我想``do``的表達方式是比較容易閱讀的。
接下來我們看看當``b``不等於``0``的時候。
我們會把``mod``的使用情況寫進log。
然後在``do``當中的第二行遞迴呼叫``gcd'``。
``gcd'``現在是回傳一個``Writer``的型態，
所以``gcd' b (a `mod` b)``這樣的寫法是完全沒問題的。

儘管去trace這個``gcd'``對於理解十分有幫助，
但我想了解整個大概念，把值視為具有context是更加有用的。

接著來試試跑我們的``gcd'``，
他的結果會是``Writer [String] Int``，
如果我們把他從``newtype``中取出來，
我們會拿到一個tuple。
tuple的第一個部份就是我們要的結果：

{{
ghci> fst $ runWriter (gcd' 8 3)  
1  
}}

至於log呢，由於log是一連串string，
我們就用``mapM_ putStrLn``來把這些string印出來：

{{
ghci> mapM_ putStrLn $ snd $ runWriter (gcd' 8 3)  
8 mod 3 = 2  
3 mod 2 = 1  
2 mod 1 = 0  
Finished with 1  
}}

把普通的演算法轉換成具有log是很棒的經驗，
我們不過是把普通的value重寫成Monadiv value，
剩下的就靠``>>=``跟``Writer``來幫我們處理一切。
用這樣的方法我們幾乎可以對任何函數加上logging的功能。
我們只要把普通的值換成``Writer``，
然後把一般的函數呼叫換成``>>=`` (當然也可以用``do``)

*Inefficient list construction*


==Reader Monad
在講Applicative的章節中，我們說過了``(->) r``的型態只是``Functor``的一個instance。
要將一個函數``f`` map over一個函數``g``，
基本上等價於一個函數，他可以接受原本``g``接受的參數，
先套用``g``然後再把其結果丟給``f``。

{{
ghci> let f = (*5)  
ghci> let g = (+3)
ghci> (fmap f g) 8
}}

我們已經見識過函數當作applicative functors的例子。
這樣能讓我們對函數的結果直接進行操作。

{{
ghci> let f = (+) <$> (*2) <*> (+10)
ghci> f 3
19
}}

``(+) <$> (*2) <*> (+10)``代表一個函數，
他接受一個數值，
分別把這數值交給``(*2)``跟``(+10)``。
然後把結果加起來。
例如說，如果我們餵``3``給這個函數，
他會分別對``3``做``(*2)``跟``(+10)``的動作。
而得到``6``跟``13``。
然後呼叫``(+)``，
而得到``19``。



==State Monad

==Error Monad

==一些實用的Moandic functions

==定義自己的Monad
